(library (matcho-tests)
  (export run-matcho-tests)
  (import (chezscheme) (test-runner) (aikanren) (datatypes) (values))

  (define (run-matcho-tests)
    (tassert "match list fail" (run1 () (let ([p '(1 2)]) (matcho ([p (a 1)])))) (void))
    (tassert "match list succeed" (run1 () (let ([p '(1 1)]) (matcho ([p (a 1)])))) '())
    (tassert "match list extract" (run1 (x1 x2) (let ([p '(1 2)]) (matcho ([p (a b)]) (== x1 a) (== x2 b)))) '(1 2))
    (tassert "match list extend" (run1 (x1) (let ([p (list 1 x1)]) (matcho ([p (a 2)])))) 2)
    (tassert "match pair fail" (run1 () (let ([p '(1 . 2)]) (matcho ([p (a . 1)])))) (void))
    (tassert "match pair succeed" (run1 () (let ([p '(1 . 1)]) (matcho ([p (a . 1)])))) '())
    (tassert "match pair extract" (run1 (x1 x2) (let ([p '(1 . 2)]) (matcho ([p (a . b)]) (== x1 a) (== x2 b)))) '(1 2))
    (tassert "match pair extend" (run1 (x1) (let ([p (cons 1 x1)]) (matcho ([p (a . 2)])))) 2)
    (tassert "match pair symbol" (run1 (x1 x2) (let ([p (cons 'one x2)]) (matcho ([p (a . 'two)]) (== a x1)))) '(one two))
    (tassert "match pair symbol list" (run1 (x1 x2) (let ([p (cons 'one x2)]) (matcho ([p (a . '(two three))]) (== a x1)))) '(one (two three)))

    (tassert "match eager" (run* (x1) (conde [(let ([p (list 1 2)]) (matcho ([p (a 2)]) (== a x1)))] [(== x1 2)])) '(1 2))
    (tassert "match lazy" (run* (x1) (conde [(let ([p (list x1 2)]) (matcho ([p (a 2)]) (== a 1)))] [(== x1 2)])) '(2 1))))
