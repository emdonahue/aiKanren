# Not Yet Implemented
-  expand-matcho ([src/mk/mk/core/reducer.ss:9](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/reducer.ss#L9))
-  normalize-matcho ([src/mk/mk/core/reducer.ss:14](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/reducer.ss#L14))
-  reduce-constraint/matcho ([src/mk/mk/core/reducer.ss:43](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/reducer.ss#L43))
-  reduce-==/matcho ([src/mk/mk/core/reducer.ss:74](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/reducer.ss#L74))
-  reduce-matcho ([src/mk/mk/core/reducer.ss:83](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/reducer.ss#L83))
-  simplify-=/= proceedure ([src/mk/mk/core/solver.ss:142](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/solver.ss#L142))
# TODO
- can alist relations just be constraints if they only return 1 and use constraint semantics to terminate search? ([src/mk/mk/lists.ss:46](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/lists.ss#L46))
- generalize from 2 arg fns ([src/mk/mk/interpreter.ss:46](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/interpreter.ss#L46))
- dual absento can potentially be sped up with store-constraint optimizations  ([src/mk/mk/interpreter.ss:64](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/interpreter.ss#L64))
- make a higher order absento that applies a fn to all variables. or really just a conjunctive tree map that lets you apply any fn ([src/mk/mk/interpreter.ss:65](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/interpreter.ss#L65))
- can lookup be a constraint? ([src/mk/mk/interpreter.ss:76](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/interpreter.ss#L76))
- replace with for-eacho and rename to for-allo ([src/mk/mk/interpreter.ss:178](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/interpreter.ss#L178))
- look into making large con/disjunctions of the same variable gather into a binary tree or something other than a random list and automatically build a decent data structure for it ([src/mk/mk/constraints.ss:10](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/constraints.ss#L10))
- try ==> as =/=|== in case =/= might be more efficient for attribution/ ([src/mk/mk/constraints.ss:15](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/constraints.ss#L15))
- do constraints need to manage recheck individually or is that just for matcho and disj? ([src/mk/mk/constraints.ss:31](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/constraints.ss#L31))
- have typeo simplify == not simply succeed or fail ([src/mk/mk/constraints.ss:43](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/constraints.ss#L43))
- print unbound variables in substitution debugging by checking var id in state ([src/mk/mk/tracing.ss:148](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/tracing.ss#L148))
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var ([src/mk/mk/core/variables.ss:5](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/variables.ss#L5))
- experiment with meta-cond for optimization time hot swaps ([src/mk/mk/core/utils.ss:35](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/utils.ss#L35))
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options ([src/mk/mk/core/utils.ss:49](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/utils.ss#L49))
- maybe fold org-tracing boolean into depth 0? ([src/mk/mk/core/utils.ss:53](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/utils.ss#L53))
- make org-lambda check for optimization and remove itself to improve performance with debugging infrastructure in place ([src/mk/mk/core/utils.ss:106](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/utils.ss#L106))
- remove streams dependency by not expanding matcho without state ([src/mk/mk/core/reducer.ss:4](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/reducer.ss#L4))
- simplify with negated pconstraints as well ([src/mk/mk/core/reducer.ss:5](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/reducer.ss#L5))
- see if normalize-matcho adds anything to solve-matcho ([src/mk/mk/core/reducer.ss:13](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/reducer.ss#L13))
- if == simplifier can confirm disj-rhs wont fail, do we need to recheck it? maybe it already contains two disjuncts with == that wont need to be rechecked ([src/mk/mk/core/reducer.ss:41](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/reducer.ss#L41))
- in simplify matcho, can i just return the g case and let one fail be enough? ([src/mk/mk/core/reducer.ss:80](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/reducer.ss#L80))
- should we thread the real state when expanding matcho while reducing ==? ([src/mk/mk/core/reducer.ss:85](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/reducer.ss#L85))
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints. also break two pairs into a conj of ==. then we can simplify the order checking inside the unifier ([src/mk/mk/core/goals.ss:32](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/goals.ss#L32))
- make proxies remove only their specific constraint and return other conjoined constraints to the store, not rerun all conjuncts. ([src/mk/mk/core/goals.ss:51](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/goals.ss#L51))
- remove debug ([src/mk/mk/core/goals.ss:105](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/goals.ss#L105))
- replace conj with make-conj or short circuiting conj* where possible, especially test in matcho for walking large ground lists ([src/mk/mk/core/goals.ss:132](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/goals.ss#L132))
- experiment with short circuiting conj and disj macros ([src/mk/mk/core/goals.ss:139](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/goals.ss#L139))
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns ([src/mk/mk/core/goals.ss:140](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/goals.ss#L140))
- is conj-fold ever used? ([src/mk/mk/core/goals.ss:183](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/goals.ss#L183))
- convert constructor fns to constructed params of structure   ([src/mk/mk/core/goals.ss:205](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/goals.ss#L205))
- microbenchmark disj cdr that looks ahead instead of using base case to check for non disj ([src/mk/mk/core/goals.ss:220](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/goals.ss#L220))
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals ([src/mk/mk/core/goals.ss:280](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/goals.ss#L280))
- make matcho work for pure values outside of mk. a la carte unification/pattern matching ([src/mk/mk/core/matcho.ss:7](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/matcho.ss#L7))
- make a special pre-sequence to bind the pure single var renames with no pair patterns ([src/mk/mk/core/matcho.ss:8](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/matcho.ss#L8))
- consider else clause for returning a new goal if matcho fails the pattern match ([src/mk/mk/core/matcho.ss:9](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/matcho.ss#L9))
- consider a cond form that nests matcho else clauses to create a cond like form without lots of negation ([src/mk/mk/core/matcho.ss:10](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/matcho.ss#L10))
- first order matcho that can be unified with a variable to destructure it. Useful for passing to functions where we dont have a reference to the variable ([src/mk/mk/core/matcho.ss:11](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/matcho.ss#L11))
- should minireify check eq or var? ([src/mk/mk/core/mini-substitution.ss:59](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/mini-substitution.ss#L59))
- double check state exports. remove extend at least ([src/mk/mk/core/state.ss:3](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L3))
- try replacing state vector copy with manual updates using mutators ([src/mk/mk/core/state.ss:11](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L11))
- remove set-state-varid ([src/mk/mk/core/state.ss:21](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L21))
- reify vars inside constraints ([src/mk/mk/core/state.ss:35](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L35))
- parameterize this into reify ([src/mk/mk/core/state.ss:48](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L48))
- is there a good opportunity to further simplify constraints rechecked by unify using the other unifications we are performing during a complex unification? currently we only simplify constraints with the unification on the variable to which they are bound, but they might contain other variables that we could simplify now and then not have to walk to look up later. maybe we combine the list of unifications and the list of constraints after return from unify ([src/mk/mk/core/state.ss:94](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L94))
- return y constraint to simplify it with potentially other bindings and also unbind its var? ([src/mk/mk/core/state.ss:148](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L148))
- see if the normalized ==s can help speed up occurs-check/binding, eg by only checking rhs terms in case of a trail of unified terms. maybe use the fact that normalized vars have directional unification? ([src/mk/mk/core/state.ss:168](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L168))
- try implementing occurs check in the constraint system and eliminating checks in the wrong id direction (eg only check lower->higher) ([src/mk/mk/core/state.ss:169](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L169))
- add a non occurs check =!= or ==! ([src/mk/mk/core/state.ss:170](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L170))
- remove double occurs check ([src/mk/mk/core/state.ss:172](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L172))
- if == simplifier can confirm disj-rhs wont fail, do we need to recheck it? maybe it already contains two disjuncts with == that wont need to be rechecked ([src/mk/mk/core/state.ss:198](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L198))
- in simplify matcho, can i just return the g case and let one fail be enough? ([src/mk/mk/core/state.ss:217](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L217))
- should we thread the real state when expanding matcho while simplifying ==? ([src/mk/mk/core/state.ss:220](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L220))
- refactor pconstraint solving/simplifying to share var iteration code among impls ([src/mk/mk/core/state.ss:226](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L226))
- make == simplifier for pconstraints check for new vars ([src/mk/mk/core/state.ss:231](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L231))
- how does disunify play with constraints in substitution? ([src/mk/mk/core/state.ss:242](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L242))
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros ([src/mk/mk/core/state.ss:261](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L261))
- consider sorting ids of variables before adding constraints to optimize adding to sbral. or possibly writing an sbral multi-add that does one pass and adds everything. would work well with sorted lists of attr vars to compare which constraints we can combine while adding ([src/mk/mk/core/state.ss:274](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/state.ss#L274))
- define a secondary run goal that runs children of conde and only that one should suspend fresh because it represents having to make a choice instead of pursuing a goal linearly into its depths ([src/mk/mk/core/search.ss:14](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/search.ss#L14))
- if we convert interleaving to cps, we can use the goal structure to store tracing info and trace the interleaving search without special affordances. might work if tracing goals just mutate rather than shadow params ([src/mk/mk/core/search.ss:15](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/search.ss#L15))
- if convert search to cps, can we use the results of walk to simplify the ctn and decide not to walk some of its goals? ([src/mk/mk/core/search.ss:16](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/search.ss#L16))
- use the ==s from constraints to simplify continuations in normal goal interpreter ([src/mk/mk/core/search.ss:33](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/search.ss#L33))
- experiment with mutation-based mplus branch swap combined with answer return in one call ([src/mk/mk/core/search.ss:44](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/search.ss#L44))
- after optimizing matcho stopping only if branch detected, consider making that a merge point for a parallel execution where the other branch is put in the queue rather than an mplus ([src/mk/mk/core/search.ss:46](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/search.ss#L46))
- perhaps instead of counting freshes we could just limit the max var id to serve as a depth proxy ([src/mk/mk/core/search.ss:71](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/search.ss#L71))
- consider analyzing goals in goal interpreter and running dfs if not recursive or only tail recursive. maybe use syntax analysis and a special conj type that marks its contents for dfs, where fresh bounces back to normal goal interpreter. it may not make a difference as outside of fresh a cps goal interpreter might be functionally depth first outside of trampolining ([src/mk/mk/core/search.ss:76](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/search.ss#L76))
- consider manipulating ctn order in dfs to get different searches, such as depth-ordered search using a functional queue to hold branching goals as the ctn ([src/mk/mk/core/search.ss:78](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/search.ss#L78))
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail ([src/mk/mk/core/solver.ss:87](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/solver.ss#L87))
- if we only get 1 binding in solve-==, it has already been simplified inside unify and we can skip it ([src/mk/mk/core/solver.ss:88](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/solver.ss#L88))
- can we simplify delta/pending as well and simplify already delta constraints from lower in the computation? ([src/mk/mk/core/solver.ss:89](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/solver.ss#L89))
- add flag to let solve-disj know that its constraint might be normalized and to skip initial solving ([src/mk/mk/core/solver.ss:102](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/solver.ss#L102))
- is mini-unify necessary in solve-disj since the constraints should be normalized so we don't have two pairs? ([src/mk/mk/core/solver.ss:118](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/solver.ss#L118))
- can we discard proxies in some cases while reducing =/=? ([src/mk/mk/core/solver.ss:143](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/solver.ss#L143))
- can we just stash the pconstraint with the simplified under certain conditions if we know it wont need further solving? ([src/mk/mk/core/solver.ss:191](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/solver.ss#L191))
- storing conj whole if lhs and rhs have same attributed vars. check attr vars of lhs and rhs. if same, pass to parent. when differ, store children independently ([src/mk/mk/core/solver.ss:266](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/solver.ss#L266))
- test whether == must attribute to both vars like =/= ([src/mk/mk/core/solver.ss:288](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/solver.ss#L288))
- Abstract out some of the math checks for navigating sbral ([src/mk/mk/core/sbral.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/sbral.ss#L1))
- put the 0 somewhere else so sbral is more aesthetic when printed ([src/mk/mk/core/sbral.ss:10](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/sbral.ss#L10))
- can sbral reference walk back up the list on the return from the recursion and rerecurse into nodes it visits along the way because early vars will always point to later vars? ([src/mk/mk/core/sbral.ss:26](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/sbral.ss#L26))
- create special purpose upsert fns in sbral that let us set and conjoin a new constraint in one operation ([src/mk/mk/core/sbral.ss:32](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/sbral.ss#L32))
- optimize sbral->alist/sbral->list ([src/mk/mk/core/sbral.ss:77](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mk/core/sbral.ss#L77))
- determine whether bind should halt after every fresh or only those that generate mplus/binds ([src/tests/goal-tests.ss:63](https://github.com/emdonahue/aiKanren/blob/main/src/tests/goal-tests.ss#L63))
- test reify cyclic once unsound unification implemented ([src/tests/goal-tests.ss:100](https://github.com/emdonahue/aiKanren/blob/main/src/tests/goal-tests.ss#L100))
- consider adding back in common factor extraction to disjunction ([src/tests/aggressive-solver-tests.ss:32](https://github.com/emdonahue/aiKanren/blob/main/src/tests/aggressive-solver-tests.ss#L32))
- can we simplify disjunctions of == and =/= of the same var? technically should be simplified to x1 =/= 1 ([src/tests/solver-tests.ss:62](https://github.com/emdonahue/aiKanren/blob/main/src/tests/solver-tests.ss#L62))
- remove proxies from secondary vars in == ([src/tests/solver-tests.ss:256](https://github.com/emdonahue/aiKanren/blob/main/src/tests/solver-tests.ss#L256))
- simplify matcho ([src/tests/reducer-tests.ss:39](https://github.com/emdonahue/aiKanren/blob/main/src/tests/reducer-tests.ss#L39))
- make tassert capture file and line number ([src/tests/test-runner.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/tests/test-runner.ss#L1))
- to allow =/= to suspend on single variable, disj must put proxies on any vars that would be touched by its disjuncts so they can rerun the disjunction ([src/tests/constraints-tests.ss:41](https://github.com/emdonahue/aiKanren/blob/main/src/tests/constraints-tests.ss#L41))
