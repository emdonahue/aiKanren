# Not Yet Implemented
-  reduce-matcho ([src/mk/reducer.ss:76](https://github.com/emdonahue/aiKanren/blob/main/src/mk/reducer.ss#L76))
-  simplify-=/= proceedure ([src/mk/solver.ss:151](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L151))
# TODO
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var ([src/mk/variables.ss:5](https://github.com/emdonahue/aiKanren/blob/main/src/mk/variables.ss#L5))
- test for-eacho with xs^ shadowing xs once matcho identifiers are fixed ([src/mk/listo.ss:35](https://github.com/emdonahue/aiKanren/blob/main/src/mk/listo.ss#L35))
- does asspo need an extra argument to succeed if none found? eg disjoin with final goal? ([src/mk/listo.ss:44](https://github.com/emdonahue/aiKanren/blob/main/src/mk/listo.ss#L44))
- merge asspo matchos into single matcho once optimized ([src/mk/listo.ss:45](https://github.com/emdonahue/aiKanren/blob/main/src/mk/listo.ss#L45))
- can alist relations just be constraints if they only return 1 and use constraint semantics to terminate search? ([src/mk/listo.ss:46](https://github.com/emdonahue/aiKanren/blob/main/src/mk/listo.ss#L46))
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options ([src/mk/utils.ss:49](https://github.com/emdonahue/aiKanren/blob/main/src/mk/utils.ss#L49))
- maybe fold org-tracing boolean into depth 0? ([src/mk/utils.ss:53](https://github.com/emdonahue/aiKanren/blob/main/src/mk/utils.ss#L53))
- make org-lambda check for optimization and remove itself to improve performance with debugging infrastructure in place ([src/mk/utils.ss:106](https://github.com/emdonahue/aiKanren/blob/main/src/mk/utils.ss#L106))
- remove streams dependency by not expanding matcho without state ([src/mk/reducer.ss:4](https://github.com/emdonahue/aiKanren/blob/main/src/mk/reducer.ss#L4))
- simplify with negated pconstraints as well ([src/mk/reducer.ss:5](https://github.com/emdonahue/aiKanren/blob/main/src/mk/reducer.ss#L5))
- see if normalize-matcho adds anything to solve-matcho ([src/mk/reducer.ss:11](https://github.com/emdonahue/aiKanren/blob/main/src/mk/reducer.ss#L11))
- if == simplifier can confirm disj-rhs wont fail, do we need to recheck it? maybe it already contains two disjuncts with == that wont need to be rechecked ([src/mk/reducer.ss:37](https://github.com/emdonahue/aiKanren/blob/main/src/mk/reducer.ss#L37))
- in simplify matcho, can i just return the g case and let one fail be enough? ([src/mk/reducer.ss:73](https://github.com/emdonahue/aiKanren/blob/main/src/mk/reducer.ss#L73))
- should we thread the real state when expanding matcho while reducing ==? ([src/mk/reducer.ss:78](https://github.com/emdonahue/aiKanren/blob/main/src/mk/reducer.ss#L78))
- delete failure.ss ([src/mk/failure.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/mk/failure.ss#L1))
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints. also break two pairs into a conj of ==. then we can simplify the order checking inside the unifier ([src/mk/goals.ss:31](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss#L31))
- make proxies remove only their specific constraint and return other conjoined constraints to the store, not rerun all conjuncts. ([src/mk/goals.ss:50](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss#L50))
- replace conj with make-conj or short circuiting conj* where possible ([src/mk/goals.ss:129](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss#L129))
- experiment with short circuiting conj and disj macros ([src/mk/goals.ss:136](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss#L136))
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns ([src/mk/goals.ss:137](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss#L137))
- is conj-fold ever used? ([src/mk/goals.ss:180](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss#L180))
- convert constructor fns to constructed params of structure   ([src/mk/goals.ss:202](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss#L202))
- microbenchmark disj cdr that looks ahead instead of using base case to check for non disj ([src/mk/goals.ss:217](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss#L217))
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals ([src/mk/goals.ss:277](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss#L277))
- first order matcho that can be unified with a variable to destructure it. Useful for passing to functions where we dont have a reference to the variable ([src/mk/matcho.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L1))
- consider a way to give matcho a global identity (maybe baking it into a defrel form?) so that matcho constraints with the same payload can simplify one another. eg, calling absento with the same payload on subparts of the same list many times ([src/mk/matcho.ss:2](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L2))
- see if normalize-matcho adds anything to solve-matcho ([src/mk/matcho.ss:21](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L21))
- integrate constraint substitutions with matcho ([src/mk/matcho.ss:33](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L33))
- generalize matcho-pair to multiple pairs, pairs with constant patterns, and other common patterns such as a-list ([src/mk/matcho.ss:51](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L51))
- specialize multiple pair matcho-pair on different modes (ground, free, etc) so we can always instantly destructure whatever is ground. may involve further manipulations of goal order based on mode ([src/mk/matcho.ss:53](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L53))
- can we make a generalized matcho out of matcho-pair on each pair of a pattern? ([src/mk/matcho.ss:54](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L54))
- specialize matcho for constraints vs goal & let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) ([src/mk/matcho.ss:89](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L89))
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts ([src/mk/matcho.ss:90](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L90))
- if matcho out-vars do not appear in the body, is there is no need to apply occurs-check constraints? ([src/mk/matcho.ss:94](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L94))
- allow matcho to match non pairs to allow constructing pairs from ground terms, and then =/= simplify should not fail on pairs for matcho ([src/mk/matcho.ss:114](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L114))
- add fender to matcho to prevent duplicate lhs vars and cyclic pattern vars (since out-vars are bound beneath in-vars, so the shadowing will go the wrong way) ([src/mk/matcho.ss:116](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L116))
- equip matcho with the patterns externally to fail constraints without invoking goal.  ([src/mk/matcho.ss:119](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L119))
- under what conditions should matcho continue? ([src/mk/matcho.ss:130](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss#L130))
- should minireify check eq or var? ([src/mk/mini-substitution.ss:59](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mini-substitution.ss#L59))
- double check state exports. remove extend at least ([src/mk/state.ss:3](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L3))
- try replacing state vector copy with manual updates using mutators ([src/mk/state.ss:11](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L11))
- remove set-state-varid ([src/mk/state.ss:21](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L21))
- reify vars inside constraints ([src/mk/state.ss:35](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L35))
- parameterize this into reify ([src/mk/state.ss:48](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L48))
- is there a good opportunity to further simplify constraints rechecked by unify using the other unifications we are performing during a complex unification? currently we only simplify constraints with the unification on the variable to which they are bound, but they might contain other variables that we could simplify now and then not have to walk to look up later. maybe we combine the list of unifications and the list of constraints after return from unify ([src/mk/state.ss:94](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L94))
- return y constraint to simplify it with potentially other bindings and also unbind its var? ([src/mk/state.ss:148](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L148))
- see if the normalized ==s can help speed up occurs-check/binding, eg by only checking rhs terms in case of a trail of unified terms. maybe use the fact that normalized vars have directional unification? ([src/mk/state.ss:168](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L168))
- try implementing occurs check in the constraint system and eliminating checks in the wrong id direction (eg only check lower->higher) ([src/mk/state.ss:169](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L169))
- add a non occurs check =!= or ==! ([src/mk/state.ss:170](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L170))
- remove double occurs check ([src/mk/state.ss:172](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L172))
- if == simplifier can confirm disj-rhs wont fail, do we need to recheck it? maybe it already contains two disjuncts with == that wont need to be rechecked ([src/mk/state.ss:198](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L198))
- in simplify matcho, can i just return the g case and let one fail be enough? ([src/mk/state.ss:217](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L217))
- should we thread the real state when expanding matcho while simplifying ==? ([src/mk/state.ss:220](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L220))
- refactor pconstraint solving/simplifying to share var iteration code among impls ([src/mk/state.ss:226](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L226))
- make == simplifier for pconstraints check for new vars ([src/mk/state.ss:231](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L231))
- how does disunify play with constraints in substitution? ([src/mk/state.ss:242](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L242))
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros ([src/mk/state.ss:261](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L261))
- consider sorting ids of variables before adding constraints to optimize adding to sbral. or possibly writing an sbral multi-add that does one pass and adds everything. would work well with sorted lists of attr vars to compare which constraints we can combine while adding ([src/mk/state.ss:274](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L274))
- rename remove-constraint -> remove-constraint ([src/mk/state.ss:283](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss#L283))
- define a secondary run goal that runs children of conde and only that one should suspend fresh because it represents having to make a choice instead of pursuing a goal linearly into its depths ([src/mk/search.ss:14](https://github.com/emdonahue/aiKanren/blob/main/src/mk/search.ss#L14))
- if we convert interleaving to cps, we can use the goal structure to store tracing info and trace the interleaving search without special affordances. might work if tracing goals just mutate rather than shadow params ([src/mk/search.ss:15](https://github.com/emdonahue/aiKanren/blob/main/src/mk/search.ss#L15))
- if convert search to cps, can we use the results of walk to simplify the ctn and decide not to walk some of its goals? ([src/mk/search.ss:16](https://github.com/emdonahue/aiKanren/blob/main/src/mk/search.ss#L16))
- check whether structural recursion check is needed anymore for matcho or if single state return is enough ([src/mk/search.ss:31](https://github.com/emdonahue/aiKanren/blob/main/src/mk/search.ss#L31))
- If any vars are non-free, there is structurally recursive information to exploit, so continue running aggressively on this branch. Otherwise suspend like a normal fresh. ([src/mk/search.ss:32](https://github.com/emdonahue/aiKanren/blob/main/src/mk/search.ss#L32))
- use the ==s from constraints to simplify continuations in normal goal interpreter ([src/mk/search.ss:40](https://github.com/emdonahue/aiKanren/blob/main/src/mk/search.ss#L40))
- experiment with mutation-based mplus branch swap combined with answer return in one call ([src/mk/search.ss:44](https://github.com/emdonahue/aiKanren/blob/main/src/mk/search.ss#L44))
- after optimizing matcho stopping only if branch detected, consider making that a merge point for a parallel execution where the other branch is put in the queue rather than an mplus ([src/mk/search.ss:46](https://github.com/emdonahue/aiKanren/blob/main/src/mk/search.ss#L46))
- perhaps instead of counting freshes we could just limit the max var id to serve as a depth proxy ([src/mk/search.ss:71](https://github.com/emdonahue/aiKanren/blob/main/src/mk/search.ss#L71))
- consider analyzing goals in goal interpreter and running dfs if not recursive or only tail recursive. maybe use syntax analysis and a special conj type that marks its contents for dfs, where fresh bounces back to normal goal interpreter. it may not make a difference as outside of fresh a cps goal interpreter might be functionally depth first outside of trampolining ([src/mk/search.ss:76](https://github.com/emdonahue/aiKanren/blob/main/src/mk/search.ss#L76))
- consider manipulating ctn order in dfs to get different searches, such as depth-ordered search using a functional queue to hold branching goals as the ctn ([src/mk/search.ss:78](https://github.com/emdonahue/aiKanren/blob/main/src/mk/search.ss#L78))
- look into making large con/disjunctions of the same variable gather into a binary tree or something other than a random list and automatically build a decent data structure for it ([src/mk/constraints.ss:10](https://github.com/emdonahue/aiKanren/blob/main/src/mk/constraints.ss#L10))
- try ==> as =/=|== in case =/= might be more efficient for attribution/ ([src/mk/constraints.ss:15](https://github.com/emdonahue/aiKanren/blob/main/src/mk/constraints.ss#L15))
- do constraints need to manage recheck individually or is that just for matcho and disj? ([src/mk/constraints.ss:31](https://github.com/emdonahue/aiKanren/blob/main/src/mk/constraints.ss#L31))
- have typeo simplify == not simply succeed or fail ([src/mk/constraints.ss:43](https://github.com/emdonahue/aiKanren/blob/main/src/mk/constraints.ss#L43))
- create defconstraint that tags any matchos returned with the function pointer so they can dedup themselves ([src/mk/constraints.ss:114](https://github.com/emdonahue/aiKanren/blob/main/src/mk/constraints.ss#L114))
- rebase solve-matcho on solve-matcho/expand ([src/mk/solver.ss:50](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L50))
- replace walkvar in matcho solver with walk once matcho handles walks ([src/mk/solver.ss:62](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L62))
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail ([src/mk/solver.ss:96](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L96))
- if we only get 1 binding in solve-==, it has already been simplified inside unify and we can skip it ([src/mk/solver.ss:97](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L97))
- can we simplify delta/pending as well and simplify already delta constraints from lower in the computation? ([src/mk/solver.ss:98](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L98))
- add flag to let solve-disj know that its constraint might be normalized and to skip initial solving ([src/mk/solver.ss:111](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L111))
- is mini-unify necessary in solve-disj since the constraints should be normalized so we don't have two pairs? ([src/mk/solver.ss:127](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L127))
- add patterns to matcho and check them in simplify-=/= ([src/mk/solver.ss:135](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L135))
- can we discard proxies in some cases while reducing =/=? ([src/mk/solver.ss:152](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L152))
- can we just stash the pconstraint with the simplified under certain conditions if we know it wont need further solving? ([src/mk/solver.ss:196](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L196))
- storing conj whole if lhs and rhs have same attributed vars. check attr vars of lhs and rhs. if same, pass to parent. when differ, store children independently ([src/mk/solver.ss:275](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L275))
- create a defrel that encodes context information about what vars were available for use in reasoning about which freshes might be able to unify them within their lexical scope ([src/mk/solver.ss:282](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L282))
- test whether == must attribute to both vars like =/= ([src/mk/solver.ss:299](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss#L299))
- Abstract out some of the math checks for navigating sbral ([src/mk/sbral.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/mk/sbral.ss#L1))
- put the 0 somewhere else so sbral is more aesthetic when printed ([src/mk/sbral.ss:10](https://github.com/emdonahue/aiKanren/blob/main/src/mk/sbral.ss#L10))
- can sbral reference walk back up the list on the return from the recursion and rerecurse into nodes it visits along the way because early vars will always point to later vars? ([src/mk/sbral.ss:26](https://github.com/emdonahue/aiKanren/blob/main/src/mk/sbral.ss#L26))
- create special purpose upsert fns in sbral that let us set and conjoin a new constraint in one operation ([src/mk/sbral.ss:32](https://github.com/emdonahue/aiKanren/blob/main/src/mk/sbral.ss#L32))
- optimize sbral->alist/sbral->list ([src/mk/sbral.ss:77](https://github.com/emdonahue/aiKanren/blob/main/src/mk/sbral.ss#L77))
- print unbound variables in substitution debugging by checking var id in state ([src/mk/tracing.ss:133](https://github.com/emdonahue/aiKanren/blob/main/src/mk/tracing.ss#L133))
- determine whether bind should halt after every fresh or only those that generate mplus/binds ([src/tests/goal-tests.ss:63](https://github.com/emdonahue/aiKanren/blob/main/src/tests/goal-tests.ss#L63))
- test reify cyclic once unsound unification implemented ([src/tests/goal-tests.ss:100](https://github.com/emdonahue/aiKanren/blob/main/src/tests/goal-tests.ss#L100))
- consider adding back in common factor extraction to disjunction ([src/tests/aggressive-solver-tests.ss:32](https://github.com/emdonahue/aiKanren/blob/main/src/tests/aggressive-solver-tests.ss#L32))
- can we simplify disjunctions of == and =/= of the same var? technically should be simplified to x1 =/= 1 ([src/tests/solver-tests.ss:65](https://github.com/emdonahue/aiKanren/blob/main/src/tests/solver-tests.ss#L65))
- remove proxies from secondary vars in == ([src/tests/solver-tests.ss:258](https://github.com/emdonahue/aiKanren/blob/main/src/tests/solver-tests.ss#L258))
- revisit matcho eagerness if all ground ([src/tests/matcho-tests.ss:26](https://github.com/emdonahue/aiKanren/blob/main/src/tests/matcho-tests.ss#L26))
- make tassert capture file and line number ([src/tests/test-runner.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/tests/test-runner.ss#L1))
- to allow =/= to suspend on single variable, disj must put proxies on any vars that would be touched by its disjuncts so they can rerun the disjunction ([src/tests/constraints-tests.ss:41](https://github.com/emdonahue/aiKanren/blob/main/src/tests/constraints-tests.ss#L41))
- quote/literal only needed if atoms in the output do not appear in the input ([src/examples/interpreter.ss:37](https://github.com/emdonahue/aiKanren/blob/main/src/examples/interpreter.ss#L37))
- can lookup be a constraint? ([src/examples/interpreter.ss:62](https://github.com/emdonahue/aiKanren/blob/main/src/examples/interpreter.ss#L62))
- enable environment variables in patterns with unquote ([src/examples/interpreter.ss:72](https://github.com/emdonahue/aiKanren/blob/main/src/examples/interpreter.ss#L72))
- can we use first order matcho to eliminate need for exist? ([src/examples/interpreter.ss:84](https://github.com/emdonahue/aiKanren/blob/main/src/examples/interpreter.ss#L84))
- can lookup be a constraint? ([src/examples/quine.ss:29](https://github.com/emdonahue/aiKanren/blob/main/src/examples/quine.ss#L29))
- enable environment variables in patterns with unquote ([src/examples/quine.ss:35](https://github.com/emdonahue/aiKanren/blob/main/src/examples/quine.ss#L35))
- merge optimized matchos ([src/examples/quine.ss:61](https://github.com/emdonahue/aiKanren/blob/main/src/examples/quine.ss#L61))
