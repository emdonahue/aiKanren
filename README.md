# aiKanren
A miniKanren implementation designed to serve as a platform for AI research combining logical and probabilistic reasoning.

## Documentation
## Not Yet Implemented
## TODO
- can we get guarded goal functionality by an == constraint and a schedule that when run unifies the guarded variables thereby triggering the unification? (build/object/aikanren.ss:1)
- do == and =/= automatically simplify when merged because we run constraints on the state not the substitution when reducing? (build/object/aikanren.ss:2)
- bool is just true or false. does this automatically gel with =/= of the other one? (build/object/aikanren.ss:3)
- we can get finite domain like ability to actually generate the answers by popping the constraint and treating it as a goal (build/object/aikanren.ss:4)
- test whether optimize level works for whole library (build/object/aikanren.ss:5)
- remove runner lib (build/object/runner.ss:1)
- delete failure.ss (build/object/failure.ss:1)
- replace assert #f with useful error messages (build/object/goals.ss:1)
- trim exports (build/object/goals.ss:3)
- do freshes that dont change the state preserve low varid count? (build/object/goals.ss:11)
- experiment with mutation-based mplus branch swap combined with answer return in one call (build/object/goals.ss:46)
- integrate constraint substitutions with matcho (build/object/matcho.ss:10)
- generalize matcho-pair to multiple pairs, pairs with constant patterns, and other common patterns such as a-list (build/object/matcho.ss:28)
- specialize multiple pair matcho-pair on different modes (ground, free, etc) so we can always instantly destructure whatever is ground. may involve further manipulations of goal order based on mode (build/object/matcho.ss:30)
- can we make a generalized matcho out of matcho-pair on each pair of a pattern? (build/object/matcho.ss:31)
- specialize matcho for constraints vs goal & let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) (build/object/matcho.ss:54)
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts (build/object/matcho.ss:55)
- add fender to matcho to prevent duplicate lhs vars (build/object/matcho.ss:74)
- equip matcho with the patterns externally to fail constraints without invoking goal.  (build/object/matcho.ss:77)
- remove mini-substitution (build/object/mini-substitution.ss:1)
- double check state exports. remove extend at least (build/object/state.ss:2)
- support cyclic terms in reifier (build/object/state.ss:11)
- is there a good opportunity to further simplify constraints rechecked by unify using the other unifications we are performing during a complex unification? currently we only simplify constraints with the unification on the variable to which they are bound, but they might contain other variables that we could simplify now and then not have to walk to look up later. maybe we combine the list of unifications and the list of constraints after return from unify (build/object/state.ss:44)
- When should simplifying a constraint commit more ==? (build/object/state.ss:54)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (build/object/state.ss:63)
- simplifiers need more thorough testing (build/object/state.ss:90)
- consider only simplifying part of disj to guarantee that analyzed constraints attribute to the currently unified pair. (build/object/state.ss:94)
- how does disunify play with constraints in substitution? (build/object/state.ss:106)
- can we extract only the subgoals that may unify when solving a =/= in disunify (build/object/state.ss:115)
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros (build/object/state.ss:133)
- simplify disunifications (build/object/state.ss:146)
- should we check multiple directions during simplification for unnormalized disjuncts? (build/object/state.ss:148)
- consider only simplifying part of disj to guarantee that analyzed constraints attribute to the currently unified pair. (build/object/state.ss:151)
- should we simplify pconstraints during disunification (build/object/state.ss:161)
- consider sorting ids of variables before adding constraints to optimize adding to sbral (build/object/state.ss:166)
- clean up state add constraint. remove dead code (build/object/state.ss:169)
- rename unbind-constraint -> remove-constraint (build/object/state.ss:178)
- delete datatypes.ss (build/object/datatypes.ss:1)
- replace conj-car/cdr with lhs/rhs (build/object/datatypes.ss:21)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (build/object/datatypes.ss:45)
- remove set-state-varid (build/object/datatypes.ss:87)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (build/object/datatypes.ss:115)
- see if normalize-matcho adds anything to solve-matcho (build/object/datatypes.ss:131)
- revisit goal-cond once fresh is either explicit or removed (build/object/datatypes.ss:138)
- replace conj with make-conj or short circuiting conj* where possible (build/object/datatypes.ss:157)
- experiment with short circuiting conj and disj macros (build/object/datatypes.ss:164)
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns (build/object/datatypes.ss:165)
- is conj-fold ever used? (build/object/datatypes.ss:199)
- have typeo simplify == not simply succeed or fail (build/object/constraints.ss:30)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms (build/object/solver.ss:36)
- quick replace extended vars in constraints looked up during unify and check for immediate failures (build/object/solver.ss:37)
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail (build/object/solver.ss:38)
- let solve constraint handle fail case (build/object/solver.ss:54)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere. However, these may nevertheless trigger unification on that var (build/object/solver.ss:60)
- let solve constraint handle fail case (build/object/solver.ss:67)
- this walk should be handled by == when it replaces var with new binding (build/object/solver.ss:76)
- just operate on the list for matcho solving (build/object/solver.ss:81)
- delete extracted == from disj clauses (build/object/solver.ss:88)
- make diff-== just a list. no need to dedup because we are dredging normalized output (build/object/solver.ss:104)
- succeed should probably skip any computations in diff-== (build/object/solver.ss:105)
- remove guardo (build/object/solver.ss:119)
- add guard rails for pconstraints returning lowest form and further solving (build/object/solver.ss:127)
- storing conj whole if lhs and rhs have same attributed vars (build/object/solver.ss:156)
- reevaluate inverting disj given that they are now binary (build/object/solver.ss:160)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (build/object/solver.ss:163)
- optimize which disj constraint we pick for attribution to minimize free vars (build/object/solver.ss:174)
- if we are checking 2 disjuncts, do we need both attr vars? (build/object/solver.ss:177)
- do we need to check as many disjuncts as have shared ==s? (build/object/solver.ss:190)
- Abstract out some of the math checks for navigating sbral (build/object/sbral.ss:1)
- put the 0 somewhere else so sbral is more aesthetic when printed (build/object/sbral.ss:10)
- make conde expand syntactically (build/object/ui.ss:5)
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals (build/object/ui.ss:11)
- make fresh-vars non-recursive ala matcho (build/object/ui.ss:69)
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (build/object/store.ss:1)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (build/object/store.ss:2)
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers (build/object/store.ss:3)
- can we get guarded goal functionality by an == constraint and a schedule that when run unifies the guarded variables thereby triggering the unification? (build/preprocessed/aikanren.ss:1)
- do == and =/= automatically simplify when merged because we run constraints on the state not the substitution when reducing? (build/preprocessed/aikanren.ss:2)
- bool is just true or false. does this automatically gel with =/= of the other one? (build/preprocessed/aikanren.ss:3)
- we can get finite domain like ability to actually generate the answers by popping the constraint and treating it as a goal (build/preprocessed/aikanren.ss:4)
- test whether optimize level works for whole library (build/preprocessed/aikanren.ss:5)
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options (build/preprocessed/utils.ss:34)
- make logging print lazily only if you log something at that trace level (build/preprocessed/utils.ss:75)
- remove runner lib (build/preprocessed/runner.ss:1)
- delete failure.ss (build/preprocessed/failure.ss:1)
- replace assert #f with useful error messages (build/preprocessed/goals.ss:1)
- trim exports (build/preprocessed/goals.ss:3)
- do freshes that dont change the state preserve low varid count? (build/preprocessed/goals.ss:11)
- experiment with mutation-based mplus branch swap combined with answer return in one call (build/preprocessed/goals.ss:46)
- integrate constraint substitutions with matcho (build/preprocessed/matcho.ss:10)
- generalize matcho-pair to multiple pairs, pairs with constant patterns, and other common patterns such as a-list (build/preprocessed/matcho.ss:28)
- specialize multiple pair matcho-pair on different modes (ground, free, etc) so we can always instantly destructure whatever is ground. may involve further manipulations of goal order based on mode (build/preprocessed/matcho.ss:30)
- can we make a generalized matcho out of matcho-pair on each pair of a pattern? (build/preprocessed/matcho.ss:31)
- specialize matcho for constraints vs goal & let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) (build/preprocessed/matcho.ss:54)
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts (build/preprocessed/matcho.ss:55)
- add fender to matcho to prevent duplicate lhs vars (build/preprocessed/matcho.ss:74)
- equip matcho with the patterns externally to fail constraints without invoking goal.  (build/preprocessed/matcho.ss:77)
- remove mini-substitution (build/preprocessed/mini-substitution.ss:1)
- double check state exports. remove extend at least (build/preprocessed/state.ss:2)
- support cyclic terms in reifier (build/preprocessed/state.ss:11)
- is there a good opportunity to further simplify constraints rechecked by unify using the other unifications we are performing during a complex unification? currently we only simplify constraints with the unification on the variable to which they are bound, but they might contain other variables that we could simplify now and then not have to walk to look up later. maybe we combine the list of unifications and the list of constraints after return from unify (build/preprocessed/state.ss:44)
- When should simplifying a constraint commit more ==? (build/preprocessed/state.ss:54)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (build/preprocessed/state.ss:63)
- simplifiers need more thorough testing (build/preprocessed/state.ss:90)
- consider only simplifying part of disj to guarantee that analyzed constraints attribute to the currently unified pair. (build/preprocessed/state.ss:94)
- how does disunify play with constraints in substitution? (build/preprocessed/state.ss:106)
- can we extract only the subgoals that may unify when solving a =/= in disunify (build/preprocessed/state.ss:115)
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros (build/preprocessed/state.ss:133)
- simplify disunifications (build/preprocessed/state.ss:146)
- should we check multiple directions during simplification for unnormalized disjuncts? (build/preprocessed/state.ss:148)
- consider only simplifying part of disj to guarantee that analyzed constraints attribute to the currently unified pair. (build/preprocessed/state.ss:151)
- should we simplify pconstraints during disunification (build/preprocessed/state.ss:161)
- consider sorting ids of variables before adding constraints to optimize adding to sbral (build/preprocessed/state.ss:166)
- clean up state add constraint. remove dead code (build/preprocessed/state.ss:169)
- rename unbind-constraint -> remove-constraint (build/preprocessed/state.ss:178)
- delete datatypes.ss (build/preprocessed/datatypes.ss:1)
- replace conj-car/cdr with lhs/rhs (build/preprocessed/datatypes.ss:21)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (build/preprocessed/datatypes.ss:45)
- remove set-state-varid (build/preprocessed/datatypes.ss:87)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (build/preprocessed/datatypes.ss:115)
- see if normalize-matcho adds anything to solve-matcho (build/preprocessed/datatypes.ss:131)
- revisit goal-cond once fresh is either explicit or removed (build/preprocessed/datatypes.ss:138)
- replace conj with make-conj or short circuiting conj* where possible (build/preprocessed/datatypes.ss:157)
- experiment with short circuiting conj and disj macros (build/preprocessed/datatypes.ss:164)
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns (build/preprocessed/datatypes.ss:165)
- is conj-fold ever used? (build/preprocessed/datatypes.ss:199)
- have typeo simplify == not simply succeed or fail (build/preprocessed/constraints.ss:30)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms (build/preprocessed/solver.ss:36)
- quick replace extended vars in constraints looked up during unify and check for immediate failures (build/preprocessed/solver.ss:37)
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail (build/preprocessed/solver.ss:38)
- let solve constraint handle fail case (build/preprocessed/solver.ss:54)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere. However, these may nevertheless trigger unification on that var (build/preprocessed/solver.ss:60)
- let solve constraint handle fail case (build/preprocessed/solver.ss:67)
- this walk should be handled by == when it replaces var with new binding (build/preprocessed/solver.ss:76)
- just operate on the list for matcho solving (build/preprocessed/solver.ss:81)
- delete extracted == from disj clauses (build/preprocessed/solver.ss:88)
- make diff-== just a list. no need to dedup because we are dredging normalized output (build/preprocessed/solver.ss:104)
- succeed should probably skip any computations in diff-== (build/preprocessed/solver.ss:105)
- remove guardo (build/preprocessed/solver.ss:119)
- add guard rails for pconstraints returning lowest form and further solving (build/preprocessed/solver.ss:127)
- storing conj whole if lhs and rhs have same attributed vars (build/preprocessed/solver.ss:156)
- reevaluate inverting disj given that they are now binary (build/preprocessed/solver.ss:160)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (build/preprocessed/solver.ss:163)
- optimize which disj constraint we pick for attribution to minimize free vars (build/preprocessed/solver.ss:174)
- if we are checking 2 disjuncts, do we need both attr vars? (build/preprocessed/solver.ss:177)
- do we need to check as many disjuncts as have shared ==s? (build/preprocessed/solver.ss:190)
- Abstract out some of the math checks for navigating sbral (build/preprocessed/sbral.ss:1)
- put the 0 somewhere else so sbral is more aesthetic when printed (build/preprocessed/sbral.ss:10)
- make conde expand syntactically (build/preprocessed/ui.ss:5)
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals (build/preprocessed/ui.ss:11)
- make fresh-vars non-recursive ala matcho (build/preprocessed/ui.ss:69)
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (build/preprocessed/store.ss:1)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (build/preprocessed/store.ss:2)
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers (build/preprocessed/store.ss:3)
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options (profile/utils.ss.html:149)
- replace assert #f with useful error messages (profile/goals.ss.html:93)
- trim exports (profile/goals.ss.html:95)
- do freshes that dont change the state preserve low varid count?</span> (profile/goals.ss.html:103)
- Abstract out some of the math checks for navigating sbral (profile/sbral.ss.html:115)
- put the 0 somewhere else so sbral is more aesthetic when printed (profile/sbral.ss.html:124)
- double check state exports (profile/state.ss.html:116)
- support cyclic terms in reifier</span> (profile/state.ss.html:125)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify</span> (profile/state.ss.html:158)
- make unifier normalize?</span> (profile/state.ss.html:164)
- delete datatypes.ss (profile/datatypes.ss.html:265)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (profile/datatypes.ss.html:309)
- remove set-state-varid</span> (profile/datatypes.ss.html:352)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (profile/datatypes.ss.html:379)
- see if normalize-matcho adds anything to solve-matcho</span> (profile/datatypes.ss.html:395)
- delete goal-cond (profile/datatypes.ss.html:401)
- replace conj with make-conj or short circuiting conj* where possible</span> (profile/datatypes.ss.html:418)
- evaluate divergence avoidance in conj goals</span> (profile/datatypes.ss.html:423)
- is conj-fold ever used?</span> (profile/datatypes.ss.html:442)
- specialize matcho for constraints vs goal &amp; let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) (profile/matcho.ss.html:136)
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts (profile/matcho.ss.html:137)
- add fender to matcho to prevent duplicate lhs vars</span> (profile/matcho.ss.html:153)
- equip matcho with the patterns externally to fail constraints without invoking goal. </span> (profile/matcho.ss.html:156)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms</span> (profile/solver.ss.html:264)
- quick replace extended vars in constraints looked up during unify and check for immediate failures</span> (profile/solver.ss.html:265)
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail</span> (profile/solver.ss.html:266)
- disunification unifier can be small step: we nly need to know 1 =/= succeeds before proceeding with search</span> (profile/solver.ss.html:275)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere</span> (profile/solver.ss.html:285)
- this walk should be handled by == when it replaces var with new binding</span> (profile/solver.ss.html:307)
- just operate on the list for matcho solving (profile/solver.ss.html:312)
- delete extracted == from disj clauses</span> (profile/solver.ss.html:318)
- make diff-== just a list. no need to dedup because we are dredging normalized output</span> (profile/solver.ss.html:334)
- succeed should probably skip any computations in diff-==</span> (profile/solver.ss.html:335)
- consider reversing constraint storage to put old constraints first</span> (profile/solver.ss.html:376)
- reevaluate inverting disj given that they are now binary (profile/solver.ss.html:380)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (profile/solver.ss.html:383)
- optimize which disj constraint we pick for attribution to minimize free vars</span> (profile/solver.ss.html:394)
- if we are checking 2 disjuncts, do we need both attr vars?</span> (profile/solver.ss.html:397)
- remove mini-substitution (profile/mini-substitution.ss.html:70)
- make conde expand syntactically (profile/ui.ss.html:124)
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals (profile/ui.ss.html:130)
- make fresh-vars non-recursive ala matcho (profile/ui.ss.html:189)
- make typo reject immediately if ground term not a type</span> (profile/constraints.ss.html:166)
profile/constraints.ss.html:242:		  <span class=pc4 title="line 100 char 3 count 99,197">;TODO(printf "A: ~s D: ~s~%" a d)</span>
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (profile/store.ss.html:71)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (profile/store.ss.html:72)
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers (profile/store.ss.html:73)
README.md:6:## TODO
- can we get guarded goal functionality by an == constraint and a schedule that when run unifies the guarded variables thereby triggering the unification? (src/mk/aikanren.ss:1)
- do == and =/= automatically simplify when merged because we run constraints on the state not the substitution when reducing? (src/mk/aikanren.ss:2)
- bool is just true or false. does this automatically gel with =/= of the other one? (src/mk/aikanren.ss:3)
- we can get finite domain like ability to actually generate the answers by popping the constraint and treating it as a goal (src/mk/aikanren.ss:4)
- test whether optimize level works for whole library (src/mk/aikanren.ss:5)
- does asspo need an extra argument to succeed if none found? eg disjoin with final goal? (src/mk/listo.ss:37)
- merge asspo matchos into single matcho once optimized (src/mk/listo.ss:38)
- create an assert macro that produces nothing when compiled at optimization level 3 and ditch the entire assertion trimming mechanism. need to also account for profiling though, so maybe disable them with a parameter as well (src/mk/utils.ss:2)
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options (src/mk/utils.ss:35)
- make logging print lazily only if you log something at that trace level (src/mk/utils.ss:76)
- remove runner lib (src/mk/runner.ss:1)
- delete failure.ss (src/mk/failure.ss:1)
- replace assert #f with useful error messages (src/mk/goals.ss:1)
- trim exports (src/mk/goals.ss:3)
- do freshes that dont change the state preserve low varid count? (src/mk/goals.ss:12)
- do freshes that dont change the state preserve low varid count? (src/mk/goals.ss:14)
- experiment with mutation-based mplus branch swap combined with answer return in one call (src/mk/goals.ss:52)
- first order matcho that can be unified with a variable to destructure it. Useful for passing to functions where we dont have a reference to the variable (src/mk/matcho.ss:2)
- integrate constraint substitutions with matcho (src/mk/matcho.ss:10)
- generalize matcho-pair to multiple pairs, pairs with constant patterns, and other common patterns such as a-list (src/mk/matcho.ss:28)
- specialize multiple pair matcho-pair on different modes (ground, free, etc) so we can always instantly destructure whatever is ground. may involve further manipulations of goal order based on mode (src/mk/matcho.ss:30)
- can we make a generalized matcho out of matcho-pair on each pair of a pattern? (src/mk/matcho.ss:31)
- specialize matcho for constraints vs goal & let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) (src/mk/matcho.ss:54)
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts (src/mk/matcho.ss:55)
- add fender to matcho to prevent duplicate lhs vars (src/mk/matcho.ss:74)
- equip matcho with the patterns externally to fail constraints without invoking goal.  (src/mk/matcho.ss:77)
- remove mini-substitution (src/mk/mini-substitution.ss:1)
- double check state exports. remove extend at least (src/mk/state.ss:2)
- is there a good opportunity to further simplify constraints rechecked by unify using the other unifications we are performing during a complex unification? currently we only simplify constraints with the unification on the variable to which they are bound, but they might contain other variables that we could simplify now and then not have to walk to look up later. maybe we combine the list of unifications and the list of constraints after return from unify (src/mk/state.ss:52)
- When should simplifying a constraint commit more ==? (src/mk/state.ss:64)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (src/mk/state.ss:73)
- simplifiers need more thorough testing (src/mk/state.ss:101)
- separate into conj and disj simplifier. conj can assume all primitive constraints attribute to var. disj simplifier has to check (src/mk/state.ss:102)
- consider only simplifying part of disj to guarantee that analyzed constraints attribute to the currently unified pair. (src/mk/state.ss:106)
- how does disunify play with constraints in substitution? (src/mk/state.ss:119)
- can we extract only the subgoals that may unify when solving a =/= in disunify (src/mk/state.ss:129)
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros (src/mk/state.ss:147)
- simplify disunifications (src/mk/state.ss:160)
- should we check multiple directions during simplification for unnormalized disjuncts? (src/mk/state.ss:162)
- consider only simplifying part of disj to guarantee that analyzed constraints attribute to the currently unified pair. (src/mk/state.ss:165)
- should we simplify pconstraints during disunification (src/mk/state.ss:175)
- consider sorting ids of variables before adding constraints to optimize adding to sbral (src/mk/state.ss:180)
- clean up state add constraint. remove dead code (src/mk/state.ss:184)
- rename unbind-constraint -> remove-constraint (src/mk/state.ss:193)
- delete datatypes.ss (src/mk/datatypes.ss:1)
- replace conj-car/cdr with lhs/rhs (src/mk/datatypes.ss:21)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (src/mk/datatypes.ss:47)
- remove set-state-varid (src/mk/datatypes.ss:93)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (src/mk/datatypes.ss:122)
- see if normalize-matcho adds anything to solve-matcho (src/mk/datatypes.ss:140)
- revisit goal-cond once fresh is either explicit or removed (src/mk/datatypes.ss:147)
- replace conj with make-conj or short circuiting conj* where possible (src/mk/datatypes.ss:166)
- experiment with short circuiting conj and disj macros (src/mk/datatypes.ss:174)
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns (src/mk/datatypes.ss:175)
- is conj-fold ever used? (src/mk/datatypes.ss:211)
- have typeo simplify == not simply succeed or fail (src/mk/constraints.ss:27)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms (src/mk/solver.ss:38)
- quick replace extended vars in constraints looked up during unify and check for immediate failures (src/mk/solver.ss:39)
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail (src/mk/solver.ss:40)
- let solve constraint handle fail case (src/mk/solver.ss:57)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere. However, these may nevertheless trigger unification on that var (src/mk/solver.ss:63)
- let solve constraint handle fail case (src/mk/solver.ss:70)
- this walk should be handled by == when it replaces var with new binding (src/mk/solver.ss:79)
- just operate on the list for matcho solving (src/mk/solver.ss:84)
- delete extracted == from disj clauses (src/mk/solver.ss:91)
- make diff-== just a list. no need to dedup because we are dredging normalized output (src/mk/solver.ss:108)
- succeed should probably skip any computations in diff-== (src/mk/solver.ss:109)
- remove guardo (src/mk/solver.ss:123)
- add guard rails for pconstraints returning lowest form and further solving (src/mk/solver.ss:131)
- storing conj whole if lhs and rhs have same attributed vars. check attr vars of lhs and rhs. if same, pass to parent. when differ, store children independently (src/mk/solver.ss:163)
- reevaluate inverting disj given that they are now binary (src/mk/solver.ss:167)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (src/mk/solver.ss:170)
- optimize which disj constraint we pick for attribution to minimize free vars (src/mk/solver.ss:181)
- if we are checking 2 disjuncts, do we need both attr vars? (src/mk/solver.ss:185)
- do we need to check as many disjuncts as have shared ==s? (src/mk/solver.ss:199)
- Abstract out some of the math checks for navigating sbral (src/mk/sbral.ss:1)
- put the 0 somewhere else so sbral is more aesthetic when printed (src/mk/sbral.ss:10)
- refactor this library into 'vars' and other (src/mk/ui.ss:1)
- make conde expand syntactically (src/mk/ui.ss:5)
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals (src/mk/ui.ss:11)
- make fresh-vars non-recursive ala matcho (src/mk/ui.ss:79)
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (src/mk/store.ss:1)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (src/mk/store.ss:2)
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers (src/mk/store.ss:3)
- implement disunification solver (src/tests/solver-tests.ss:43)
- check that attr vars for diseq should be first 2 vs 1 (src/tests/solver-tests.ss:102)
- make tassert capture file and line number (src/tests/test-runner.ss:1)
- test multi-success disj that should succeed instead of suspending as constraint. maybe normalize before starting constraint walk. maybe already handled by normalizing resulting constraint (src/tests/constraints-tests.ss:1)
- can lookup be a constraint? (src/examples/interpreter.ss:42)
- enable environment variables in patterns with unquote (src/examples/interpreter.ss:51)
- can we use first order matcho to eliminate need for exist? (src/examples/interpreter.ss:63)
