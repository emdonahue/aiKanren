# aiKanren
A miniKanren implementation designed to serve as a platform for AI research combining logical and probabilistic reasoning.

## Documentation
## TODO
- can we get guarded goal functionality by an == constraint and a schedule that when run unifies the guarded variables thereby triggering the unification? (build/preprocessed/aikanren.ss:1)
- do == and =/= automatically simplify when merged because we run constraints on the state not the substitution when reducing? (build/preprocessed/aikanren.ss:2)
- bool is just true or false. does this automatically gel with =/= of the other one? (build/preprocessed/aikanren.ss:3)
- we can get finite domain like ability to actually generate the answers by popping the constraint and treating it as a goal (build/preprocessed/aikanren.ss:4)
- test whether optimize level works for whole library (build/preprocessed/aikanren.ss:5)
- remove runner lib (build/preprocessed/runner.ss:1)
- delete failure.ss (build/preprocessed/failure.ss:1)
- replace assert #f with useful error messages (build/preprocessed/goals.ss:1)
- trim exports (build/preprocessed/goals.ss:3)
- do freshes that dont change the state preserve low varid count? (build/preprocessed/goals.ss:11)
- remove mini-substitution (build/preprocessed/mini-substitution.ss:1)
- double check state exports (build/preprocessed/state.ss:2)
- support cyclic terms in reifier (build/preprocessed/state.ss:11)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (build/preprocessed/state.ss:44)
- make unifier normalize? (build/preprocessed/state.ss:50)
- delete datatypes.ss (build/preprocessed/datatypes.ss:1)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (build/preprocessed/datatypes.ss:43)
- remove set-state-varid (build/preprocessed/datatypes.ss:84)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (build/preprocessed/datatypes.ss:111)
- delete goal-cond (build/preprocessed/datatypes.ss:123)
- replace conj with make-conj where possible (build/preprocessed/datatypes.ss:130)
- evaluate divergence avoidance in conj goals (build/preprocessed/datatypes.ss:135)
- is conj-fold ever used? (build/preprocessed/datatypes.ss:147)
- try making constraint freshes that don't bind any external variables just commit. eg for ground terms. maybe their partner in == is ground or also from a constraint fresh? (build/preprocessed/constraints.ss:100)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms (build/preprocessed/solver.ss:26)
- disunification unifier can be small step: we nly need to know 1 =/= succeeds before proceeding with search (build/preprocessed/solver.ss:35)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere (build/preprocessed/solver.ss:53)
- if we maintain a list of all simplified == and =/= seen in each simplified disjunct, we can keep consuming disjuncts until the list of those that have appeared in each case is empty. if we get to the end and some still appear in that case, we'll want to factor them out of the disj and apply them to the state. as an optimization, if the list of values in any state is already exactly that list, we can just reuse that state instead of reapplying them to the blank state (build/preprocessed/solver.ss:76)
- do we need to solve disjs that dont contain any ==? in fact, we can stop as soon as we find one such disjunct. in fact, that disjunct MUST unify if we are to care about it, so the == must be in the top level conjunction of the goal (build/preprocessed/solver.ss:80)
- be more specific about how many disjuncts we need attr vars from (build/preprocessed/solver.ss:115)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (build/preprocessed/solver.ss:121)
- optimize which disj constraint we pick for attribution to minimize free vars (build/preprocessed/solver.ss:132)
- if we are checking 2 disjuncts, do we need both attr vars? (build/preprocessed/solver.ss:135)
- Abstract out some of the math checks for navigating sbral (build/preprocessed/sbral.ss:1)
- put the 0 somewhere else so sbral is more aesthetic when printed (build/preprocessed/sbral.ss:10)
- make conde expand syntactically (build/preprocessed/ui.ss:5)
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (build/preprocessed/store.ss:1)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (build/preprocessed/store.ss:2)
Makefile:63:	echo '## TODO' >> README.md
- (.*)/- \2 (\1)/' >> README.md (Makefile:64)
- replace assert #f with useful error messages (profile/goals.ss.html:93)
- trim exports (profile/goals.ss.html:95)
- do freshes that dont change the state preserve low varid count?</span> (profile/goals.ss.html:101)
- Abstract out some of the math checks for navigating sbral (profile/sbral.ss.html:115)
- put the 0 somewhere else so sbral is more aesthetic when printed (profile/sbral.ss.html:124)
- double check state exports (profile/state.ss.html:116)
- support cyclic terms in reifier</span> (profile/state.ss.html:125)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify</span> (profile/state.ss.html:158)
- make unifier normalize?</span> (profile/state.ss.html:164)
- delete datatypes.ss (profile/datatypes.ss.html:202)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (profile/datatypes.ss.html:244)
- remove set-state-varid</span> (profile/datatypes.ss.html:285)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (profile/datatypes.ss.html:312)
- evaluate divergence avoidance in conj goals</span> (profile/datatypes.ss.html:330)
- is conj-fold ever used?</span> (profile/datatypes.ss.html:342)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms</span> (profile/solver.ss.html:208)
- disunification unifier can be small step: we nly need to know 1 =/= succeeds before proceeding with search</span> (profile/solver.ss.html:217)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere</span> (profile/solver.ss.html:235)
- if we maintain a list of all simplified == and =/= seen in each simplified disjunct, we can keep consuming disjuncts until the list of those that have appeared in each case is empty. if we get to the end and some still appear in that case, we'll want to factor them out of the disj and apply them to the state. as an optimization, if the list of values in any state is already exactly that list, we can just reuse that state instead of reapplying them to the blank state</span> (profile/solver.ss.html:258)
- do we need to solve disjs that dont contain any ==? in fact, we can stop as soon as we find one such disjunct. in fact, that disjunct MUST unify if we are to care about it, so the == must be in the top level conjunction of the goal</span> (profile/solver.ss.html:262)
- be more specific about how many disjuncts we need attr vars from</span> (profile/solver.ss.html:297)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars</span> (profile/solver.ss.html:303)
- optimize which disj constraint we pick for attribution to minimize free vars</span> (profile/solver.ss.html:314)
- if we are checking 2 disjuncts, do we need both attr vars?</span> (profile/solver.ss.html:317)
- try making constraint freshes that don't bind any external variables just commit. eg for ground terms. maybe their partner in == is ground or also from a constraint fresh?</span> (profile/constraints.ss.html:282)
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (profile/store.ss.html:70)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (profile/store.ss.html:71)
README.md:5:## TODO
- can we get guarded goal functionality by an == constraint and a schedule that when run unifies the guarded variables thereby triggering the unification? (src/aikanren/aikanren.ss:1)
- do == and =/= automatically simplify when merged because we run constraints on the state not the substitution when reducing? (src/aikanren/aikanren.ss:2)
- bool is just true or false. does this automatically gel with =/= of the other one? (src/aikanren/aikanren.ss:3)
- we can get finite domain like ability to actually generate the answers by popping the constraint and treating it as a goal (src/aikanren/aikanren.ss:4)
- test whether optimize level works for whole library (src/aikanren/aikanren.ss:5)
- remove runner lib (src/aikanren/runner.ss:1)
- delete failure.ss (src/aikanren/failure.ss:1)
src/aikanren/README.md:5:## TODO
- replace assert #f with useful error messages (src/aikanren/goals.ss:1)
- trim exports (src/aikanren/goals.ss:3)
- do freshes that dont change the state preserve low varid count? (src/aikanren/goals.ss:12)
- remove mini-substitution (src/aikanren/mini-substitution.ss:1)
- double check state exports (src/aikanren/state.ss:2)
- support cyclic terms in reifier (src/aikanren/state.ss:11)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (src/aikanren/state.ss:46)
- make unifier normalize? (src/aikanren/state.ss:52)
- delete datatypes.ss (src/aikanren/datatypes.ss:1)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (src/aikanren/datatypes.ss:44)
- remove set-state-varid (src/aikanren/datatypes.ss:88)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (src/aikanren/datatypes.ss:116)
- delete goal-cond (src/aikanren/datatypes.ss:128)
- replace conj with make-conj where possible (src/aikanren/datatypes.ss:135)
- evaluate divergence avoidance in conj goals (src/aikanren/datatypes.ss:141)
- is conj-fold ever used? (src/aikanren/datatypes.ss:155)
- try making constraint freshes that don't bind any external variables just commit. eg for ground terms. maybe their partner in == is ground or also from a constraint fresh? (src/aikanren/constraints.ss:103)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms (src/aikanren/solver.ss:28)
- disunification unifier can be small step: we nly need to know 1 =/= succeeds before proceeding with search (src/aikanren/solver.ss:37)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere (src/aikanren/solver.ss:56)
- break fail and succeed into separate cases (src/aikanren/solver.ss:81)
- replace disj with make-disj where possible (src/aikanren/solver.ss:88)
- succeed should probably skip any computations in diff-== (src/aikanren/solver.ss:96)
- be more specific about how many disjuncts we need attr vars from (src/aikanren/solver.ss:132)
- reevaluate inverting disj given that they are now binary (src/aikanren/solver.ss:137)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (src/aikanren/solver.ss:140)
- optimize which disj constraint we pick for attribution to minimize free vars (src/aikanren/solver.ss:151)
- if we are checking 2 disjuncts, do we need both attr vars? (src/aikanren/solver.ss:155)
- Abstract out some of the math checks for navigating sbral (src/aikanren/sbral.ss:1)
- put the 0 somewhere else so sbral is more aesthetic when printed (src/aikanren/sbral.ss:10)
- make conde expand syntactically (src/aikanren/ui.ss:5)
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (src/aikanren/store.ss:1)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (src/aikanren/store.ss:2)
- make tassert capture file and line number (tests/test-runner.ss:1)
- test multi-success disj that should succeed instead of suspending as constraint. maybe normalize before starting constraint walk. maybe already handled by normalizing resulting constraint (tests/constraints-tests.ss:1)
- if simp level is 1, we dont need to attribute to 2 disjuncts (tests/constraints-tests.ss:98)
- check that attr vars for diseq should be first 2 vs 1 (tests/constraints-tests.ss:136)
