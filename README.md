# aiKanren
A miniKanren implementation designed to serve as a platform for AI research combining logical and probabilistic reasoning.

## Documentation
## Not Yet Implemented
-  abort-early-simplify-=/= (src/mk/solver.ss:102)
-  simplify-neg-pconstraint (src/mk/solver.ss:110)
-  passing-pconstraint (src/mk/solver.ss:118)
## TODO
- can we get guarded goal functionality by an == constraint and a schedule that when run unifies the guarded variables thereby triggering the unification? (build/object/aikanren.ss:1)
- do == and =/= automatically simplify when merged because we run constraints on the state not the substitution when reducing? (build/object/aikanren.ss:2)
- bool is just true or false. does this automatically gel with =/= of the other one? (build/object/aikanren.ss:3)
- we can get finite domain like ability to actually generate the answers by popping the constraint and treating it as a goal (build/object/aikanren.ss:4)
- test whether optimize level works for whole library (build/object/aikanren.ss:5)
- remove runner lib (build/object/runner.ss:1)
- delete failure.ss (build/object/failure.ss:1)
- replace assert #f with useful error messages (build/object/goals.ss:1)
- trim exports (build/object/goals.ss:3)
- do freshes that dont change the state preserve low varid count? (build/object/goals.ss:11)
- experiment with mutation-based mplus branch swap combined with answer return in one call (build/object/goals.ss:46)
- integrate constraint substitutions with matcho (build/object/matcho.ss:10)
- generalize matcho-pair to multiple pairs, pairs with constant patterns, and other common patterns such as a-list (build/object/matcho.ss:28)
- specialize multiple pair matcho-pair on different modes (ground, free, etc) so we can always instantly destructure whatever is ground. may involve further manipulations of goal order based on mode (build/object/matcho.ss:30)
- can we make a generalized matcho out of matcho-pair on each pair of a pattern? (build/object/matcho.ss:31)
- specialize matcho for constraints vs goal & let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) (build/object/matcho.ss:54)
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts (build/object/matcho.ss:55)
- add fender to matcho to prevent duplicate lhs vars (build/object/matcho.ss:74)
- equip matcho with the patterns externally to fail constraints without invoking goal.  (build/object/matcho.ss:77)
- remove mini-substitution (build/object/mini-substitution.ss:1)
- double check state exports. remove extend at least (build/object/state.ss:2)
- support cyclic terms in reifier (build/object/state.ss:11)
- is there a good opportunity to further simplify constraints rechecked by unify using the other unifications we are performing during a complex unification? currently we only simplify constraints with the unification on the variable to which they are bound, but they might contain other variables that we could simplify now and then not have to walk to look up later. maybe we combine the list of unifications and the list of constraints after return from unify (build/object/state.ss:44)
- When should simplifying a constraint commit more ==? (build/object/state.ss:54)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (build/object/state.ss:63)
- simplifiers need more thorough testing (build/object/state.ss:90)
- consider only simplifying part of disj to guarantee that analyzed constraints attribute to the currently unified pair. (build/object/state.ss:94)
- how does disunify play with constraints in substitution? (build/object/state.ss:106)
- can we extract only the subgoals that may unify when solving a =/= in disunify (build/object/state.ss:115)
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros (build/object/state.ss:133)
- simplify disunifications (build/object/state.ss:146)
- should we check multiple directions during simplification for unnormalized disjuncts? (build/object/state.ss:148)
- consider only simplifying part of disj to guarantee that analyzed constraints attribute to the currently unified pair. (build/object/state.ss:151)
- should we simplify pconstraints during disunification (build/object/state.ss:161)
- consider sorting ids of variables before adding constraints to optimize adding to sbral (build/object/state.ss:166)
- clean up state add constraint. remove dead code (build/object/state.ss:169)
- rename unbind-constraint -> remove-constraint (build/object/state.ss:178)
- delete datatypes.ss (build/object/datatypes.ss:1)
- replace conj-car/cdr with lhs/rhs (build/object/datatypes.ss:21)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (build/object/datatypes.ss:45)
- remove set-state-varid (build/object/datatypes.ss:87)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (build/object/datatypes.ss:115)
- see if normalize-matcho adds anything to solve-matcho (build/object/datatypes.ss:131)
- revisit goal-cond once fresh is either explicit or removed (build/object/datatypes.ss:138)
- replace conj with make-conj or short circuiting conj* where possible (build/object/datatypes.ss:157)
- experiment with short circuiting conj and disj macros (build/object/datatypes.ss:164)
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns (build/object/datatypes.ss:165)
- is conj-fold ever used? (build/object/datatypes.ss:199)
- have typeo simplify == not simply succeed or fail (build/object/constraints.ss:30)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms (build/object/solver.ss:36)
- quick replace extended vars in constraints looked up during unify and check for immediate failures (build/object/solver.ss:37)
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail (build/object/solver.ss:38)
- let solve constraint handle fail case (build/object/solver.ss:54)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere. However, these may nevertheless trigger unification on that var (build/object/solver.ss:60)
- let solve constraint handle fail case (build/object/solver.ss:67)
- this walk should be handled by == when it replaces var with new binding (build/object/solver.ss:76)
- just operate on the list for matcho solving (build/object/solver.ss:81)
- delete extracted == from disj clauses (build/object/solver.ss:88)
- make diff-== just a list. no need to dedup because we are dredging normalized output (build/object/solver.ss:104)
- succeed should probably skip any computations in diff-== (build/object/solver.ss:105)
- remove guardo (build/object/solver.ss:119)
- add guard rails for pconstraints returning lowest form and further solving (build/object/solver.ss:127)
- storing conj whole if lhs and rhs have same attributed vars (build/object/solver.ss:156)
- reevaluate inverting disj given that they are now binary (build/object/solver.ss:160)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (build/object/solver.ss:163)
- optimize which disj constraint we pick for attribution to minimize free vars (build/object/solver.ss:174)
- if we are checking 2 disjuncts, do we need both attr vars? (build/object/solver.ss:177)
- do we need to check as many disjuncts as have shared ==s? (build/object/solver.ss:190)
- Abstract out some of the math checks for navigating sbral (build/object/sbral.ss:1)
- put the 0 somewhere else so sbral is more aesthetic when printed (build/object/sbral.ss:10)
- make conde expand syntactically (build/object/ui.ss:5)
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals (build/object/ui.ss:11)
- make fresh-vars non-recursive ala matcho (build/object/ui.ss:69)
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (build/object/store.ss:1)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (build/object/store.ss:2)
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers (build/object/store.ss:3)
- can we get guarded goal functionality by an == constraint and a schedule that when run unifies the guarded variables thereby triggering the unification? (build/preprocessed/aikanren.ss:1)
- do == and =/= automatically simplify when merged because we run constraints on the state not the substitution when reducing? (build/preprocessed/aikanren.ss:2)
- bool is just true or false. does this automatically gel with =/= of the other one? (build/preprocessed/aikanren.ss:3)
- we can get finite domain like ability to actually generate the answers by popping the constraint and treating it as a goal (build/preprocessed/aikanren.ss:4)
- test whether optimize level works for whole library (build/preprocessed/aikanren.ss:5)
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options (build/preprocessed/utils.ss:34)
- make logging print lazily only if you log something at that trace level (build/preprocessed/utils.ss:75)
- remove runner lib (build/preprocessed/runner.ss:1)
- delete failure.ss (build/preprocessed/failure.ss:1)
- replace assert #f with useful error messages (build/preprocessed/goals.ss:1)
- trim exports (build/preprocessed/goals.ss:3)
- do freshes that dont change the state preserve low varid count? (build/preprocessed/goals.ss:11)
- experiment with mutation-based mplus branch swap combined with answer return in one call (build/preprocessed/goals.ss:46)
- integrate constraint substitutions with matcho (build/preprocessed/matcho.ss:10)
- generalize matcho-pair to multiple pairs, pairs with constant patterns, and other common patterns such as a-list (build/preprocessed/matcho.ss:28)
- specialize multiple pair matcho-pair on different modes (ground, free, etc) so we can always instantly destructure whatever is ground. may involve further manipulations of goal order based on mode (build/preprocessed/matcho.ss:30)
- can we make a generalized matcho out of matcho-pair on each pair of a pattern? (build/preprocessed/matcho.ss:31)
- specialize matcho for constraints vs goal & let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) (build/preprocessed/matcho.ss:54)
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts (build/preprocessed/matcho.ss:55)
- add fender to matcho to prevent duplicate lhs vars (build/preprocessed/matcho.ss:74)
- equip matcho with the patterns externally to fail constraints without invoking goal.  (build/preprocessed/matcho.ss:77)
- remove mini-substitution (build/preprocessed/mini-substitution.ss:1)
- double check state exports. remove extend at least (build/preprocessed/state.ss:2)
- support cyclic terms in reifier (build/preprocessed/state.ss:11)
- is there a good opportunity to further simplify constraints rechecked by unify using the other unifications we are performing during a complex unification? currently we only simplify constraints with the unification on the variable to which they are bound, but they might contain other variables that we could simplify now and then not have to walk to look up later. maybe we combine the list of unifications and the list of constraints after return from unify (build/preprocessed/state.ss:44)
- When should simplifying a constraint commit more ==? (build/preprocessed/state.ss:54)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (build/preprocessed/state.ss:63)
- simplifiers need more thorough testing (build/preprocessed/state.ss:90)
- consider only simplifying part of disj to guarantee that analyzed constraints attribute to the currently unified pair. (build/preprocessed/state.ss:94)
- how does disunify play with constraints in substitution? (build/preprocessed/state.ss:106)
- can we extract only the subgoals that may unify when solving a =/= in disunify (build/preprocessed/state.ss:115)
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros (build/preprocessed/state.ss:133)
- simplify disunifications (build/preprocessed/state.ss:146)
- should we check multiple directions during simplification for unnormalized disjuncts? (build/preprocessed/state.ss:148)
- consider only simplifying part of disj to guarantee that analyzed constraints attribute to the currently unified pair. (build/preprocessed/state.ss:151)
- should we simplify pconstraints during disunification (build/preprocessed/state.ss:161)
- consider sorting ids of variables before adding constraints to optimize adding to sbral (build/preprocessed/state.ss:166)
- clean up state add constraint. remove dead code (build/preprocessed/state.ss:169)
- rename unbind-constraint -> remove-constraint (build/preprocessed/state.ss:178)
- delete datatypes.ss (build/preprocessed/datatypes.ss:1)
- replace conj-car/cdr with lhs/rhs (build/preprocessed/datatypes.ss:21)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (build/preprocessed/datatypes.ss:45)
- remove set-state-varid (build/preprocessed/datatypes.ss:87)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (build/preprocessed/datatypes.ss:115)
- see if normalize-matcho adds anything to solve-matcho (build/preprocessed/datatypes.ss:131)
- revisit goal-cond once fresh is either explicit or removed (build/preprocessed/datatypes.ss:138)
- replace conj with make-conj or short circuiting conj* where possible (build/preprocessed/datatypes.ss:157)
- experiment with short circuiting conj and disj macros (build/preprocessed/datatypes.ss:164)
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns (build/preprocessed/datatypes.ss:165)
- is conj-fold ever used? (build/preprocessed/datatypes.ss:199)
- have typeo simplify == not simply succeed or fail (build/preprocessed/constraints.ss:30)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms (build/preprocessed/solver.ss:36)
- quick replace extended vars in constraints looked up during unify and check for immediate failures (build/preprocessed/solver.ss:37)
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail (build/preprocessed/solver.ss:38)
- let solve constraint handle fail case (build/preprocessed/solver.ss:54)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere. However, these may nevertheless trigger unification on that var (build/preprocessed/solver.ss:60)
- let solve constraint handle fail case (build/preprocessed/solver.ss:67)
- this walk should be handled by == when it replaces var with new binding (build/preprocessed/solver.ss:76)
- just operate on the list for matcho solving (build/preprocessed/solver.ss:81)
- delete extracted == from disj clauses (build/preprocessed/solver.ss:88)
- make diff-== just a list. no need to dedup because we are dredging normalized output (build/preprocessed/solver.ss:104)
- succeed should probably skip any computations in diff-== (build/preprocessed/solver.ss:105)
- remove guardo (build/preprocessed/solver.ss:119)
- add guard rails for pconstraints returning lowest form and further solving (build/preprocessed/solver.ss:127)
- storing conj whole if lhs and rhs have same attributed vars (build/preprocessed/solver.ss:156)
- reevaluate inverting disj given that they are now binary (build/preprocessed/solver.ss:160)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (build/preprocessed/solver.ss:163)
- optimize which disj constraint we pick for attribution to minimize free vars (build/preprocessed/solver.ss:174)
- if we are checking 2 disjuncts, do we need both attr vars? (build/preprocessed/solver.ss:177)
- do we need to check as many disjuncts as have shared ==s? (build/preprocessed/solver.ss:190)
- Abstract out some of the math checks for navigating sbral (build/preprocessed/sbral.ss:1)
- put the 0 somewhere else so sbral is more aesthetic when printed (build/preprocessed/sbral.ss:10)
- make conde expand syntactically (build/preprocessed/ui.ss:5)
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals (build/preprocessed/ui.ss:11)
- make fresh-vars non-recursive ala matcho (build/preprocessed/ui.ss:69)
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (build/preprocessed/store.ss:1)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (build/preprocessed/store.ss:2)
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers (build/preprocessed/store.ss:3)
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options (profile/utils.ss.html:149)
- replace assert #f with useful error messages (profile/goals.ss.html:93)
- trim exports (profile/goals.ss.html:95)
- do freshes that dont change the state preserve low varid count?</span> (profile/goals.ss.html:103)
- Abstract out some of the math checks for navigating sbral (profile/sbral.ss.html:115)
- put the 0 somewhere else so sbral is more aesthetic when printed (profile/sbral.ss.html:124)
- double check state exports (profile/state.ss.html:116)
- support cyclic terms in reifier</span> (profile/state.ss.html:125)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify</span> (profile/state.ss.html:158)
- make unifier normalize?</span> (profile/state.ss.html:164)
- delete datatypes.ss (profile/datatypes.ss.html:265)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (profile/datatypes.ss.html:309)
- remove set-state-varid</span> (profile/datatypes.ss.html:352)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (profile/datatypes.ss.html:379)
- see if normalize-matcho adds anything to solve-matcho</span> (profile/datatypes.ss.html:395)
- delete goal-cond (profile/datatypes.ss.html:401)
- replace conj with make-conj or short circuiting conj* where possible</span> (profile/datatypes.ss.html:418)
- evaluate divergence avoidance in conj goals</span> (profile/datatypes.ss.html:423)
- is conj-fold ever used?</span> (profile/datatypes.ss.html:442)
- specialize matcho for constraints vs goal &amp; let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) (profile/matcho.ss.html:136)
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts (profile/matcho.ss.html:137)
- add fender to matcho to prevent duplicate lhs vars</span> (profile/matcho.ss.html:153)
- equip matcho with the patterns externally to fail constraints without invoking goal. </span> (profile/matcho.ss.html:156)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms</span> (profile/solver.ss.html:264)
- quick replace extended vars in constraints looked up during unify and check for immediate failures</span> (profile/solver.ss.html:265)
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail</span> (profile/solver.ss.html:266)
- disunification unifier can be small step: we nly need to know 1 =/= succeeds before proceeding with search</span> (profile/solver.ss.html:275)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere</span> (profile/solver.ss.html:285)
- this walk should be handled by == when it replaces var with new binding</span> (profile/solver.ss.html:307)
- just operate on the list for matcho solving (profile/solver.ss.html:312)
- delete extracted == from disj clauses</span> (profile/solver.ss.html:318)
- make diff-== just a list. no need to dedup because we are dredging normalized output</span> (profile/solver.ss.html:334)
- succeed should probably skip any computations in diff-==</span> (profile/solver.ss.html:335)
- consider reversing constraint storage to put old constraints first</span> (profile/solver.ss.html:376)
- reevaluate inverting disj given that they are now binary (profile/solver.ss.html:380)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (profile/solver.ss.html:383)
- optimize which disj constraint we pick for attribution to minimize free vars</span> (profile/solver.ss.html:394)
- if we are checking 2 disjuncts, do we need both attr vars?</span> (profile/solver.ss.html:397)
- remove mini-substitution (profile/mini-substitution.ss.html:70)
- make conde expand syntactically (profile/ui.ss.html:124)
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals (profile/ui.ss.html:130)
- make fresh-vars non-recursive ala matcho (profile/ui.ss.html:189)
- make typo reject immediately if ground term not a type</span> (profile/constraints.ss.html:166)
profile/constraints.ss.html:242:		  <span class=pc4 title="line 100 char 3 count 99,197">;TODO(printf "A: ~s D: ~s~%" a d)</span>
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (profile/store.ss.html:71)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (profile/store.ss.html:72)
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers (profile/store.ss.html:73)
README.md:9:## TODO
- can we get guarded goal functionality by an == constraint and a schedule that when run unifies the guarded variables thereby triggering the unification? (src/mk/aikanren.ss:1)
- do == and =/= automatically simplify when merged because we run constraints on the state not the substitution when reducing? (src/mk/aikanren.ss:2)
- bool is just true or false. does this automatically gel with =/= of the other one? (src/mk/aikanren.ss:3)
- we can get finite domain like ability to actually generate the answers by popping the constraint and treating it as a goal (src/mk/aikanren.ss:4)
- test whether optimize level works for whole library (src/mk/aikanren.ss:5)
- test for-eacho with xs^ shadowing xs once matcho identifiers are fixed (src/mk/listo.ss:29)
- does asspo need an extra argument to succeed if none found? eg disjoin with final goal? (src/mk/listo.ss:36)
- merge asspo matchos into single matcho once optimized (src/mk/listo.ss:37)
- can alist relations just be constraints if they only return 1 and use constraint semantics to terminate search? (src/mk/listo.ss:38)
- have cert test conditions individually and print the failing condition (src/mk/utils.ss:34)
- update cert to produce nothing when compiled at optimization level 3 and ditch the entire assertion trimming mechanism. need to also account for profiling though, so maybe disable them with a parameter as well (src/mk/utils.ss:35)
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options (src/mk/utils.ss:46)
- maybe fold org-tracing boolean into depth 0? (src/mk/utils.ss:50)
- delete failure.ss (src/mk/failure.ss:1)
- replace assert #f with useful error messages (src/mk/goals.ss:1)
- define a secondary run goal that runs children of conde and only that one should suspend fresh because it represents having to make a choice instead of pursuing a goal linearly into its depths (src/mk/goals.ss:8)
- if we convert interleaving to cps, we can use the goal structure to store tracing info and trace the interleaving search without special affordances. might work if tracing goals just mutate rather than shadow params (src/mk/goals.ss:9)
- if convert search to cps, can we use the results of walk to simplify the ctn and decide not to walk some of its goals? (src/mk/goals.ss:10)
- do freshes that dont change the state preserve low varid count? (src/mk/goals.ss:17)
- separate suspended into its own constraint and treat procedures as ad hoc goals to be run immediately. ad hoc goals that already guarantee normal form can simply return succeed and the new state/package (src/mk/goals.ss:18)
- do freshes that dont change the state preserve low varid count? (src/mk/goals.ss:19)
- check whether structural recursion check is needed anymore for matcho or if single state return is enough (src/mk/goals.ss:26)
- move trace-goal to a procedure that checks for tracing params and only returns trace goal objects if tracing, otherwise noop and can remove from non tracing interpreters (src/mk/goals.ss:34)
- use the ==s from constraints to simplify continuations in normal goal interpreter (src/mk/goals.ss:35)
- consider making bind cps (src/mk/goals.ss:50)
- consider analyzing goals in goal interpreter and running dfs if not recursive or only tail recursive. may require converting everything to cps. maybe use syntax analysis and a special conj type that marks its contents for dfs, where fresh bounces back to normal goal interpreter. it may not make a difference as outside of fresh a cps goal interpreter might be functionally depth first outside of trampolining (src/mk/goals.ss:72)
- if we put run-goal-dfs in a parameter the tracing system will have a callback fn and we can trace without modifying the dfs (src/mk/goals.ss:73)
- consider manipulating ctn order in dfs to get different searches, such as depth-ordered search using a functional queue to hold branching goals as the ctn (src/mk/goals.ss:74)
- experiment with mutation-based mplus branch swap combined with answer return in one call (src/mk/goals.ss:95)
- first order matcho that can be unified with a variable to destructure it. Useful for passing to functions where we dont have a reference to the variable (src/mk/matcho.ss:1)
- consider a way to give matcho a global identity (maybe baking it into a defrel form?) so that matcho constraints with the same payload can simplify one another. eg, calling absento with the same payload on subparts of the same list many times (src/mk/matcho.ss:2)
- integrate constraint substitutions with matcho (src/mk/matcho.ss:12)
- generalize matcho-pair to multiple pairs, pairs with constant patterns, and other common patterns such as a-list (src/mk/matcho.ss:30)
- specialize multiple pair matcho-pair on different modes (ground, free, etc) so we can always instantly destructure whatever is ground. may involve further manipulations of goal order based on mode (src/mk/matcho.ss:32)
- can we make a generalized matcho out of matcho-pair on each pair of a pattern? (src/mk/matcho.ss:33)
- specialize matcho for constraints vs goal & let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) (src/mk/matcho.ss:63)
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts (src/mk/matcho.ss:64)
- if matcho out-vars do not appear in the body, is there is no need to apply occurs-check constraints? (src/mk/matcho.ss:68)
- add fender to matcho to prevent duplicate lhs vars and cyclic pattern vars (since out-vars are bound beneath in-vars, so the shadowing will go the wrong way) (src/mk/matcho.ss:86)
- equip matcho with the patterns externally to fail constraints without invoking goal.  (src/mk/matcho.ss:89)
- under what conditions should matcho continue? (src/mk/matcho.ss:100)
- remove mini-substitution (src/mk/mini-substitution.ss:1)
- double check state exports. remove extend at least (src/mk/state.ss:2)
- replace unbound with success as null element in state (src/mk/state.ss:6)
- is there a good opportunity to further simplify constraints rechecked by unify using the other unifications we are performing during a complex unification? currently we only simplify constraints with the unification on the variable to which they are bound, but they might contain other variables that we could simplify now and then not have to walk to look up later. maybe we combine the list of unifications and the list of constraints after return from unify (src/mk/state.ss:67)
- When should simplifying a constraint commit more ==? (src/mk/state.ss:79)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (src/mk/state.ss:88)
- simplifiers need more thorough testing (src/mk/state.ss:116)
- separate into conj and disj simplifier. conj can assume all primitive constraints attribute to var. disj simplifier has to check (src/mk/state.ss:117)
- consider only simplifying part of disj to guarantee that analyzed constraints attribute to the currently unified pair. (src/mk/state.ss:121)
- how does disunify play with constraints in substitution? (src/mk/state.ss:134)
- we may not need to simplify y goal in disunify so return it separately (src/mk/state.ss:144)
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros (src/mk/state.ss:162)
- simplify disunifications (src/mk/state.ss:188)
- should we check multiple directions during simplification for unnormalized disjuncts? (src/mk/state.ss:190)
- consider only simplifying part of disj to guarantee that analyzed constraints attribute to the currently unified pair. (src/mk/state.ss:193)
- should we simplify pconstraints during disunification (src/mk/state.ss:203)
- consider sorting ids of variables before adding constraints to optimize adding to sbral (src/mk/state.ss:208)
- clean up state add constraint. remove dead code (src/mk/state.ss:212)
- rename unbind-constraint -> remove-constraint (src/mk/state.ss:221)
- delete datatypes.ss (src/mk/datatypes.ss:1)
- replace conj-car/cdr with lhs/rhs (src/mk/datatypes.ss:21)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (src/mk/datatypes.ss:49)
- remove set-state-varid (src/mk/datatypes.ss:101)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (src/mk/datatypes.ss:130)
- see if normalize-matcho adds anything to solve-matcho (src/mk/datatypes.ss:148)
- revisit goal-cond once fresh is either explicit or removed (src/mk/datatypes.ss:159)
- replace conj with make-conj or short circuiting conj* where possible (src/mk/datatypes.ss:195)
- experiment with short circuiting conj and disj macros (src/mk/datatypes.ss:203)
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns (src/mk/datatypes.ss:204)
- remove conj-car (src/mk/datatypes.ss:220)
- is conj-fold ever used? (src/mk/datatypes.ss:252)
- convert constructor fns to constructed params of structure   (src/mk/datatypes.ss:262)
- microbenchmark disj cdr that looks ahead instead of using base case to check for non disj (src/mk/datatypes.ss:278)
- try ==> as =/=|== in case =/= might be more efficient for attribution/ (src/mk/constraints.ss:12)
- have typeo simplify == not simply succeed or fail (src/mk/constraints.ss:32)
- create defconstraint that tags any matchos returned with the function pointer so they can dedup themselves (src/mk/constraints.ss:101)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms (src/mk/solver.ss:39)
- quick replace extended vars in constraints looked up during unify and check for immediate failures (src/mk/solver.ss:40)
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail (src/mk/solver.ss:41)
- can we sort our conjunctions into those containing variables not touched by the current unifications and so may need to be further walked/solved and those that we can just directly strap on to the out parameter now? may have to do with analyzing which ones have disjunctions that are still normalized even after updates with current unifications (src/mk/solver.ss:42)
- we can construct the unified normalized goal as a binary tree no var ids and make it faster to use it as a mini substitution for further simplification (src/mk/solver.ss:43)
- add a non occurs check =!= or ==! (src/mk/solver.ss:49)
- can we pack eigen checks onto occurs check and get them for free? (src/mk/solver.ss:50)
- see if the normalized ==s can help speed up occurs-check, eg by only checking rhs terms in case of a trail of unified terms. maybe use the fact that normalized vars have directional unification? (src/mk/solver.ss:57)
- let solve constraint handle fail case (src/mk/solver.ss:80)
- potential opportunity to store the whole disjunction instead of just the head and reuse the state if =/= is the top level disjunction (src/mk/solver.ss:83)
- =/= can simplify more precisely against matcho if it uses the actual pattern and not just pair? (src/mk/solver.ss:115)
- replace walkvar in matcho solver with walk once matcho handles walks (src/mk/solver.ss:130)
- this walk should be handled by == when it replaces var with new binding (src/mk/solver.ss:131)
- if we get a non pair, we can fail matcho right away without expanding lambda (src/mk/solver.ss:132)
- just operate on the list for matcho solving (src/mk/solver.ss:136)
- solve-disj should compress disjs with shared == into one disjunct conjoined to the == (src/mk/solver.ss:139)
- disj can use solved head disjs to propagate simplifying info to other disjuncts (src/mk/solver.ss:146)
- do we have to continue to check ==s if the returned disj might commit? (src/mk/solver.ss:153)
- remove guardo (src/mk/solver.ss:168)
- add guard rails for pconstraints returning lowest form and further solving (src/mk/solver.ss:177)
- solve-pconstraint really only needs to be called the first time. after that pconstraints solve themselves (src/mk/solver.ss:178)
- add guard rails for pconstraints returning lowest form and further solving (src/mk/solver.ss:193)
- == should be propagated up and stored at top level, not after every disj. we should propagate one commited conj and one uncommited conj (src/mk/solver.ss:207)
- storing conj whole if lhs and rhs have same attributed vars. check attr vars of lhs and rhs. if same, pass to parent. when differ, store children independently (src/mk/solver.ss:227)
- reevaluate inverting disj given that they are now binary (src/mk/solver.ss:231)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (src/mk/solver.ss:234)
- thread trace-goal through other critical infrastructure so its semantically transparent (src/mk/solver.ss:240)
- create a defrel that encodes context information about what vars were available for use in reasoning about which freshes might be able to unify them within their lexical scope (src/mk/solver.ss:242)
- Abstract out some of the math checks for navigating sbral (src/mk/sbral.ss:1)
- put the 0 somewhere else so sbral is more aesthetic when printed (src/mk/sbral.ss:10)
- can sbral reference walk back up the list on the return from the recursion and rerecurse into nodes it visits along the way because early vars will always point to later vars? (src/mk/sbral.ss:26)
- create special purpose upsert fns in sbral that let us set and conjoin a new constraint in one operation (src/mk/sbral.ss:32)
- optimize sbral->alist/sbral->list (src/mk/sbral.ss:77)
- refactor this library into 'vars' and other (src/mk/ui.ss:1)
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals (src/mk/ui.ss:9)
- make conde do fail checks syntactically (src/mk/ui.ss:18)
- make fresh-vars non-recursive ala matcho (src/mk/ui.ss:126)
- make goal-cond automatically add a condition for trace goals when not compiling and make trace goals vanish when compiling (test (optimize-level) param? (src/mk/tracing.ss:14)
- make all goals accept a list of states so that we can print only the code as written and the input and output states without having to multiplex the code points for the tracing interpreter (src/mk/tracing.ss:28)
- DRY the matcho/exist/fresh calls to common calling interface. maybe use => cond interface (src/mk/tracing.ss:37)
- might be able to fold proofs into standard dfs with parameters and get rid of special cps trace interpreter (src/mk/tracing.ss:56)
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (src/mk/store.ss:1)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (src/mk/store.ss:2)
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers (src/mk/store.ss:3)
- determine whether bind should halt after every fresh or only those that generate mplus/binds (src/tests/goals-tests.ss:40)
- test reify cyclic once unsound unification implemented (src/tests/goals-tests.ss:59)
- make  (src/tests/goals-tests.ss:61)
- implement disunification solver (src/tests/solver-tests.ss:43)
- can we simplify disjunctions of == and =/= of the same var? technically should be simplified to x1 =/= 1 (src/tests/solver-tests.ss:63)
- check that attr vars for diseq should be first 2 vs 1 (src/tests/solver-tests.ss:134)
- revisit matcho eagerness if all ground (src/tests/matcho-tests.ss:26)
- make tassert capture file and line number (src/tests/test-runner.ss:1)
- test multi-success disj that should succeed instead of suspending as constraint. maybe normalize before starting constraint walk. maybe already handled by normalizing resulting constraint (src/tests/constraints-tests.ss:1)
- test that recursive disjunctions containing unifications dont run forever looking for a case that doesn't involve == when attributing/solving disjunctions (src/tests/constraints-tests.ss:272)
- can lookup be a constraint? (src/examples/interpreter.ss:42)
- enable environment variables in patterns with unquote (src/examples/interpreter.ss:51)
- can we use first order matcho to eliminate need for exist? (src/examples/interpreter.ss:63)
- can lookup be a constraint? (src/examples/quine.ss:29)
- enable environment variables in patterns with unquote (src/examples/quine.ss:35)
- merge optimized matchos (src/examples/quine.ss:61)
