# aiKanren
A miniKanren implementation designed to serve as a platform for AI research combining logical and probabilistic reasoning.

## Documentation
## Not Yet Implemented
-  simplify-=/= proceedure (build/preprocessed/solver.ss:128)
-  nyi (profile/utils.ss.html:209)
-  simplify-=/= proceedure (src/mk/solver.ss:142)
## TODO
- quote/literal only needed if atoms in the output do not appear in the input ([build/benchmarks/interpreter.ss:37](https://github.com/emdonahue/aiKanren/blob/main/build/benchmarks/interpreter.ss:37))
- can lookup be a constraint? ([build/benchmarks/interpreter.ss:62](https://github.com/emdonahue/aiKanren/blob/main/build/benchmarks/interpreter.ss:62))
- enable environment variables in patterns with unquote ([build/benchmarks/interpreter.ss:72](https://github.com/emdonahue/aiKanren/blob/main/build/benchmarks/interpreter.ss:72))
- can we use first order matcho to eliminate need for exist? ([build/benchmarks/interpreter.ss:84](https://github.com/emdonahue/aiKanren/blob/main/build/benchmarks/interpreter.ss:84))
- can lookup be a constraint? ([build/benchmarks/quine.ss:29](https://github.com/emdonahue/aiKanren/blob/main/build/benchmarks/quine.ss:29))
- enable environment variables in patterns with unquote ([build/benchmarks/quine.ss:35](https://github.com/emdonahue/aiKanren/blob/main/build/benchmarks/quine.ss:35))
- merge optimized matchos ([build/benchmarks/quine.ss:61](https://github.com/emdonahue/aiKanren/blob/main/build/benchmarks/quine.ss:61))
- can we get guarded goal functionality by an == constraint and a schedule that when run unifies the guarded variables thereby triggering the unification? ([build/preprocessed/aikanren.ss:1](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/aikanren.ss:1))
- do == and =/= automatically simplify when merged because we run constraints on the state not the substitution when reducing? ([build/preprocessed/aikanren.ss:2](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/aikanren.ss:2))
- bool is just true or false. does this automatically gel with =/= of the other one? ([build/preprocessed/aikanren.ss:3](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/aikanren.ss:3))
- we can get finite domain like ability to actually generate the answers by popping the constraint and treating it as a goal ([build/preprocessed/aikanren.ss:4](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/aikanren.ss:4))
- test whether optimize level works for whole library ([build/preprocessed/aikanren.ss:5](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/aikanren.ss:5))
- test for-eacho with xs^ shadowing xs once matcho identifiers are fixed ([build/preprocessed/listo.ss:34](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/listo.ss:34))
- does asspo need an extra argument to succeed if none found? eg disjoin with final goal? ([build/preprocessed/listo.ss:41](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/listo.ss:41))
- merge asspo matchos into single matcho once optimized ([build/preprocessed/listo.ss:42](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/listo.ss:42))
- can alist relations just be constraints if they only return 1 and use constraint semantics to terminate search? ([build/preprocessed/listo.ss:43](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/listo.ss:43))
- update cert to produce nothing when compiled at optimization level 3 and ditch the entire assertion trimming mechanism. need to also account for profiling though, so maybe disable them with a parameter as well ([build/preprocessed/utils.ss:35](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/utils.ss:35))
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options ([build/preprocessed/utils.ss:46](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/utils.ss:46))
- maybe fold org-tracing boolean into depth 0? ([build/preprocessed/utils.ss:50](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/utils.ss:50))
- make org-lambda check for optimization and remove itself to improve performance with debugging infrastructure in place ([build/preprocessed/utils.ss:100](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/utils.ss:100))
- simplify with negated pconstraints as well ([build/preprocessed/reducer.ss:5](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/reducer.ss:5))
- delete failure.ss ([build/preprocessed/failure.ss:1](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/failure.ss:1))
- replace assert #f with useful error messages ([build/preprocessed/goals.ss:1](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:1))
- define a secondary run goal that runs children of conde and only that one should suspend fresh because it represents having to make a choice instead of pursuing a goal linearly into its depths ([build/preprocessed/goals.ss:8](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:8))
- if we convert interleaving to cps, we can use the goal structure to store tracing info and trace the interleaving search without special affordances. might work if tracing goals just mutate rather than shadow params ([build/preprocessed/goals.ss:9](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:9))
- if convert search to cps, can we use the results of walk to simplify the ctn and decide not to walk some of its goals? ([build/preprocessed/goals.ss:10](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:10))
- do freshes that dont change the state preserve low varid count? ([build/preprocessed/goals.ss:15](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:15))
- separate suspended into its own constraint and treat procedures as ad hoc goals to be run immediately. ad hoc goals that already guarantee normal form can simply return succeed and the new state/package ([build/preprocessed/goals.ss:16](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:16))
- do freshes that dont change the state preserve low varid count? ([build/preprocessed/goals.ss:17](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:17))
- check whether structural recursion check is needed anymore for matcho or if single state return is enough ([build/preprocessed/goals.ss:24](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:24))
- move trace-goal to a procedure that checks for tracing params and only returns trace goal objects if tracing, otherwise noop and can remove from non tracing interpreters ([build/preprocessed/goals.ss:32](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:32))
- use the ==s from constraints to simplify continuations in normal goal interpreter ([build/preprocessed/goals.ss:33](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:33))
- consider making bind cps ([build/preprocessed/goals.ss:47](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:47))
- consider analyzing goals in goal interpreter and running dfs if not recursive or only tail recursive. may require converting everything to cps. maybe use syntax analysis and a special conj type that marks its contents for dfs, where fresh bounces back to normal goal interpreter. it may not make a difference as outside of fresh a cps goal interpreter might be functionally depth first outside of trampolining ([build/preprocessed/goals.ss:67](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:67))
- if we put run-goal-dfs in a parameter the tracing system will have a callback fn and we can trace without modifying the dfs ([build/preprocessed/goals.ss:68](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:68))
- consider manipulating ctn order in dfs to get different searches, such as depth-ordered search using a functional queue to hold branching goals as the ctn ([build/preprocessed/goals.ss:69](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:69))
- experiment with mutation-based mplus branch swap combined with answer return in one call ([build/preprocessed/goals.ss:90](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:90))
- after optimizing matcho stopping only if branch detected, consider making that a merge point for a parallel execution where the other branch is put in the queue rather than an mplus ([build/preprocessed/goals.ss:91](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/goals.ss:91))
- first order matcho that can be unified with a variable to destructure it. Useful for passing to functions where we dont have a reference to the variable ([build/preprocessed/matcho.ss:1](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/matcho.ss:1))
- consider a way to give matcho a global identity (maybe baking it into a defrel form?) so that matcho constraints with the same payload can simplify one another. eg, calling absento with the same payload on subparts of the same list many times ([build/preprocessed/matcho.ss:2](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/matcho.ss:2))
- integrate constraint substitutions with matcho ([build/preprocessed/matcho.ss:12](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/matcho.ss:12))
- generalize matcho-pair to multiple pairs, pairs with constant patterns, and other common patterns such as a-list ([build/preprocessed/matcho.ss:30](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/matcho.ss:30))
- specialize multiple pair matcho-pair on different modes (ground, free, etc) so we can always instantly destructure whatever is ground. may involve further manipulations of goal order based on mode ([build/preprocessed/matcho.ss:32](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/matcho.ss:32))
- can we make a generalized matcho out of matcho-pair on each pair of a pattern? ([build/preprocessed/matcho.ss:33](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/matcho.ss:33))
- specialize matcho for constraints vs goal & let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) ([build/preprocessed/matcho.ss:63](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/matcho.ss:63))
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts ([build/preprocessed/matcho.ss:64](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/matcho.ss:64))
- if matcho out-vars do not appear in the body, is there is no need to apply occurs-check constraints? ([build/preprocessed/matcho.ss:68](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/matcho.ss:68))
- allow matcho to match non pairs to allow constructing pairs from ground terms, and then =/= simplify should not fail on pairs for matcho ([build/preprocessed/matcho.ss:88](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/matcho.ss:88))
- add fender to matcho to prevent duplicate lhs vars and cyclic pattern vars (since out-vars are bound beneath in-vars, so the shadowing will go the wrong way) ([build/preprocessed/matcho.ss:90](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/matcho.ss:90))
- equip matcho with the patterns externally to fail constraints without invoking goal.  ([build/preprocessed/matcho.ss:93](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/matcho.ss:93))
- under what conditions should matcho continue? ([build/preprocessed/matcho.ss:104](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/matcho.ss:104))
- should minireify check eq or var? ([build/preprocessed/mini-substitution.ss:51](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/mini-substitution.ss:51))
- double check state exports. remove extend at least ([build/preprocessed/state.ss:2](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:2))
- replace unbound with success as null element in state ([build/preprocessed/state.ss:6](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:6))
- reify vars inside constraints ([build/preprocessed/state.ss:10](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:10))
- is there a good opportunity to further simplify constraints rechecked by unify using the other unifications we are performing during a complex unification? currently we only simplify constraints with the unification on the variable to which they are bound, but they might contain other variables that we could simplify now and then not have to walk to look up later. maybe we combine the list of unifications and the list of constraints after return from unify ([build/preprocessed/state.ss:59](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:59))
- When should simplifying a constraint commit more ==? ([build/preprocessed/state.ss:72](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:72))
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify ([build/preprocessed/state.ss:81](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:81))
- unify should simplify constraints together as it conjoins them, or perhaps in solve-== after they have all been normalized ([build/preprocessed/state.ss:87](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:87))
- return val constraint to simplify it with potentially other bindings and also unbind its var? ([build/preprocessed/state.ss:96](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:96))
- if == simplifier can confirm disj-rhs wont fail, do we need to recheck it? maybe it already contains two disjuncts with == that wont need to be rechecked ([build/preprocessed/state.ss:120](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:120))
- in simplify matcho, can i just return the g case and let one fail be enough? ([build/preprocessed/state.ss:146](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:146))
- should we thread the real state when expanding matcho while simplifying ==? ([build/preprocessed/state.ss:149](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:149))
- refactor pconstraint solving/simplifying to share var iteration code among impls ([build/preprocessed/state.ss:153](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:153))
- make == simplifier for pconstraints check for new vars ([build/preprocessed/state.ss:158](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:158))
- how does disunify play with constraints in substitution? ([build/preprocessed/state.ss:168](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:168))
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros ([build/preprocessed/state.ss:186](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:186))
- consider sorting ids of variables before adding constraints to optimize adding to sbral. or possibly writing an sbral multi-add that does one pass and adds everything. would work well with sorted lists of attr vars to compare which constraints we can combine while adding ([build/preprocessed/state.ss:193](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:193))
- clean up state add constraint. remove dead code ([build/preprocessed/state.ss:214](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:214))
- rename unbind-constraint -> remove-constraint ([build/preprocessed/state.ss:223](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/state.ss:223))
- delete datatypes.ss ([build/preprocessed/datatypes.ss:1](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:1))
- replace conj-car/cdr with lhs/rhs ([build/preprocessed/datatypes.ss:21](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:21))
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var ([build/preprocessed/datatypes.ss:48](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:48))
- try replacing state vector copy with manual updates using mutators ([build/preprocessed/datatypes.ss:94](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:94))
- remove set-state-varid ([build/preprocessed/datatypes.ss:111](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:111))
- rename state-or-failure? to maybe-state? ([build/preprocessed/datatypes.ss:116](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:116))
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints. also break two pairs into a conj of ==. then we can simplify the order checking inside the unifier ([build/preprocessed/datatypes.ss:138](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:138))
- == should put vars first so it has a better chance of simplifying in the ctn ([build/preprocessed/datatypes.ss:147](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:147))
- the double pair case for == should factorize into a conj of ==. this can then simplify the unifier's order checking ([build/preprocessed/datatypes.ss:149](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:149))
- see if normalize-matcho adds anything to solve-matcho ([build/preprocessed/datatypes.ss:156](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:156))
- revisit goal-cond once fresh is either explicit or removed ([build/preprocessed/datatypes.ss:185](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:185))
- replace conj with make-conj or short circuiting conj* where possible ([build/preprocessed/datatypes.ss:221](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:221))
- experiment with short circuiting conj and disj macros ([build/preprocessed/datatypes.ss:229](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:229))
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns ([build/preprocessed/datatypes.ss:230](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:230))
- remove conj-car ([build/preprocessed/datatypes.ss:246](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:246))
- is conj-fold ever used? ([build/preprocessed/datatypes.ss:276](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:276))
- convert constructor fns to constructed params of structure   ([build/preprocessed/datatypes.ss:285](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:285))
- microbenchmark disj cdr that looks ahead instead of using base case to check for non disj ([build/preprocessed/datatypes.ss:300](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/datatypes.ss:300))
- look into making large con/disjunctions of the same variable gather into a binary tree or something other than a random list and automatically build a decent data structure for it ([build/preprocessed/constraints.ss:8](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/constraints.ss:8))
- try ==> as =/=|== in case =/= might be more efficient for attribution/ ([build/preprocessed/constraints.ss:11](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/constraints.ss:11))
- do constraints need to manage recheck individually or is that just for matcho and disj? ([build/preprocessed/constraints.ss:25](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/constraints.ss:25))
- have typeo simplify == not simply succeed or fail ([build/preprocessed/constraints.ss:35](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/constraints.ss:35))
- create defconstraint that tags any matchos returned with the function pointer so they can dedup themselves ([build/preprocessed/constraints.ss:103](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/constraints.ss:103))
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms ([build/preprocessed/solver.ss:54](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:54))
- quick replace extended vars in constraints looked up during unify and check for immediate failures ([build/preprocessed/solver.ss:55](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:55))
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail ([build/preprocessed/solver.ss:56](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:56))
- can we sort our conjunctions into those containing variables not touched by the current unifications and so may need to be further walked/solved and those that we can just directly strap on to the out parameter now? may have to do with analyzing which ones have disjunctions that are still normalized even after updates with current unifications ([build/preprocessed/solver.ss:57](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:57))
- we can construct the unified normalized goal as a binary tree no var ids and make it faster to use it as a mini substitution for further simplification ([build/preprocessed/solver.ss:58](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:58))
- test whether repeated variable transfers inside a disj crowd up the pending constraint ([build/preprocessed/solver.ss:59](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:59))
- we only need to resimplify if bindings contains a free-free pair (otherwise all individual simplifications are already complete ([build/preprocessed/solver.ss:64](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:64))
- see if the normalized ==s can help speed up occurs-check/binding, eg by only checking rhs terms in case of a trail of unified terms. maybe use the fact that normalized vars have directional unification? ([build/preprocessed/solver.ss:81](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:81))
- try implementing occurs check in the constraint system and eliminating checks in the wrong id direction (eg only check lower->higher) ([build/preprocessed/solver.ss:82](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:82))
- add a non occurs check =!= or ==! ([build/preprocessed/solver.ss:83](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:83))
- can we just add the =/= disjunction directly to the state and let the solver deal with it? might have to report it as added rather than pending once the two constraint return system is in place ([build/preprocessed/solver.ss:94](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:94))
- add flag to let solve-disj know that its constraint might be normalized and to skip initial solving ([build/preprocessed/solver.ss:97](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:97))
- is mini-unify necessary in solve-disj since the constraints should be normalized so we don't have two pairs? ([build/preprocessed/solver.ss:111](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:111))
- add patterns to matcho and check them in simplify-=/= ([build/preprocessed/solver.ss:118](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:118))
- replace walkvar in matcho solver with walk once matcho handles walks ([build/preprocessed/solver.ss:157](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:157))
- this walk should be handled by == when it replaces var with new binding ([build/preprocessed/solver.ss:158](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:158))
- if we get a non pair, we can fail matcho right away without expanding lambda ([build/preprocessed/solver.ss:159](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:159))
- just operate on the list for matcho solving ([build/preprocessed/solver.ss:163](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:163))
- split g in solve-disj into normalized and unnormalized args to let other fns flexibly avoid double solving already normalized constraints ([build/preprocessed/solver.ss:166](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:166))
- deal with non left branching disjs that may be created dynamically by =/= or matcho. fundamentally we have to thread information from the first disj through to others and treat them linearly ([build/preprocessed/solver.ss:171](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:171))
- can we just stash the pconstraint with the simplified under certain conditions if we know it wont need further solving? ([build/preprocessed/solver.ss:192](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:192))
- make store constraint put disj right and everything else left ([build/preprocessed/solver.ss:260](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:260))
- storing conj whole if lhs and rhs have same attributed vars. check attr vars of lhs and rhs. if same, pass to parent. when differ, store children independently ([build/preprocessed/solver.ss:265](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:265))
- thread trace-goal through other critical infrastructure so its semantically transparent ([build/preprocessed/solver.ss:270](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:270))
- create a defrel that encodes context information about what vars were available for use in reasoning about which freshes might be able to unify them within their lexical scope ([build/preprocessed/solver.ss:272](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:272))
- do we need to check for recheckable matchos when attributing disj? ([build/preprocessed/solver.ss:277](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/solver.ss:277))
- Abstract out some of the math checks for navigating sbral ([build/preprocessed/sbral.ss:1](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/sbral.ss:1))
- put the 0 somewhere else so sbral is more aesthetic when printed ([build/preprocessed/sbral.ss:10](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/sbral.ss:10))
- can sbral reference walk back up the list on the return from the recursion and rerecurse into nodes it visits along the way because early vars will always point to later vars? ([build/preprocessed/sbral.ss:26](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/sbral.ss:26))
- create special purpose upsert fns in sbral that let us set and conjoin a new constraint in one operation ([build/preprocessed/sbral.ss:32](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/sbral.ss:32))
- optimize sbral->alist/sbral->list ([build/preprocessed/sbral.ss:76](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/sbral.ss:76))
- refactor this library into 'vars' and other ([build/preprocessed/ui.ss:1](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/ui.ss:1))
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals ([build/preprocessed/ui.ss:10](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/ui.ss:10))
- make conde do fail checks syntactically ([build/preprocessed/ui.ss:19](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/ui.ss:19))
- make fresh-vars non-recursive ala matcho ([build/preprocessed/ui.ss:132](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/ui.ss:132))
- make goal-cond automatically add a condition for trace goals when not compiling and make trace goals vanish when compiling (test (optimize-level) param? ([build/preprocessed/tracing.ss:14](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/tracing.ss:14))
- make all goals accept a list of states so that we can print only the code as written and the input and output states without having to multiplex the code points for the tracing interpreter ([build/preprocessed/tracing.ss:30](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/tracing.ss:30))
- DRY the matcho/exist/fresh calls to common calling interface. maybe use => cond interface ([build/preprocessed/tracing.ss:38](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/tracing.ss:38))
- might be able to fold proofs into standard dfs with parameters and get rid of special cps trace interpreter ([build/preprocessed/tracing.ss:56](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/tracing.ss:56))
- print unbound variables in substitution debugging by checking var id in state ([build/preprocessed/tracing.ss:146](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/tracing.ss:146))
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times ([build/preprocessed/store.ss:1](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/store.ss:1))
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them ([build/preprocessed/store.ss:2](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/store.ss:2))
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers ([build/preprocessed/store.ss:3](https://github.com/emdonahue/aiKanren/blob/main/build/preprocessed/store.ss:3))
- have cert test conditions individually and print the failing condition ([profile/utils.ss.html:213](https://github.com/emdonahue/aiKanren/blob/main/profile/utils.ss.html:213))
- update cert to produce nothing when compiled at optimization level 3 and ditch the entire assertion trimming mechanism. need to also account for profiling though, so maybe disable them with a parameter as well ([profile/utils.ss.html:214](https://github.com/emdonahue/aiKanren/blob/main/profile/utils.ss.html:214))
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options ([profile/utils.ss.html:225](https://github.com/emdonahue/aiKanren/blob/main/profile/utils.ss.html:225))
- maybe fold org-tracing boolean into depth 0? ([profile/utils.ss.html:229](https://github.com/emdonahue/aiKanren/blob/main/profile/utils.ss.html:229))
- make org-lambda check for optimization and remove itself to improve performance with debugging infrastructure in place ([profile/utils.ss.html:277](https://github.com/emdonahue/aiKanren/blob/main/profile/utils.ss.html:277))
- replace assert #f with useful error messages ([profile/goals.ss.html:137](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:137))
- define a secondary run goal that runs children of conde and only that one should suspend fresh because it represents having to make a choice instead of pursuing a goal linearly into its depths</span> ([profile/goals.ss.html:144](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:144))
- if we convert interleaving to cps, we can use the goal structure to store tracing info and trace the interleaving search without special affordances. might work if tracing goals just mutate rather than shadow params</span> ([profile/goals.ss.html:145](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:145))
- if convert search to cps, can we use the results of walk to simplify the ctn and decide not to walk some of its goals?</span> ([profile/goals.ss.html:146](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:146))
- do freshes that dont change the state preserve low varid count?</span> ([profile/goals.ss.html:151](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:151))
- separate suspended into its own constraint and treat procedures as ad hoc goals to be run immediately. ad hoc goals that already guarantee normal form can simply return succeed and the new state/package</span> ([profile/goals.ss.html:152](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:152))
- do freshes that dont change the state preserve low varid count?</span> ([profile/goals.ss.html:153](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:153))
- check whether structural recursion check is needed anymore for matcho or if single state return is enough</span> ([profile/goals.ss.html:160](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:160))
- move trace-goal to a procedure that checks for tracing params and only returns trace goal objects if tracing, otherwise noop and can remove from non tracing interpreters</span> ([profile/goals.ss.html:168](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:168))
- use the ==s from constraints to simplify continuations in normal goal interpreter</span> ([profile/goals.ss.html:169](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:169))
- consider making bind cps</span> ([profile/goals.ss.html:183](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:183))
- consider analyzing goals in goal interpreter and running dfs if not recursive or only tail recursive. may require converting everything to cps. maybe use syntax analysis and a special conj type that marks its contents for dfs, where fresh bounces back to normal goal interpreter. it may not make a difference as outside of fresh a cps goal interpreter might be functionally depth first outside of trampolining</span> ([profile/goals.ss.html:203](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:203))
- if we put run-goal-dfs in a parameter the tracing system will have a callback fn and we can trace without modifying the dfs</span> ([profile/goals.ss.html:204](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:204))
- consider manipulating ctn order in dfs to get different searches, such as depth-ordered search using a functional queue to hold branching goals as the ctn</span> ([profile/goals.ss.html:205](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:205))
- experiment with mutation-based mplus branch swap combined with answer return in one call</span> ([profile/goals.ss.html:226](https://github.com/emdonahue/aiKanren/blob/main/profile/goals.ss.html:226))
- Abstract out some of the math checks for navigating sbral ([profile/sbral.ss.html:118](https://github.com/emdonahue/aiKanren/blob/main/profile/sbral.ss.html:118))
- put the 0 somewhere else so sbral is more aesthetic when printed ([profile/sbral.ss.html:127](https://github.com/emdonahue/aiKanren/blob/main/profile/sbral.ss.html:127))
- can sbral reference walk back up the list on the return from the recursion and rerecurse into nodes it visits along the way because early vars will always point to later vars?</span> ([profile/sbral.ss.html:143](https://github.com/emdonahue/aiKanren/blob/main/profile/sbral.ss.html:143))
- create special purpose upsert fns in sbral that let us set and conjoin a new constraint in one operation</span> ([profile/sbral.ss.html:149](https://github.com/emdonahue/aiKanren/blob/main/profile/sbral.ss.html:149))
- optimize sbral-&gt;alist/sbral-&gt;list</span> ([profile/sbral.ss.html:193](https://github.com/emdonahue/aiKanren/blob/main/profile/sbral.ss.html:193))
- double check state exports. remove extend at least ([profile/state.ss.html:202](https://github.com/emdonahue/aiKanren/blob/main/profile/state.ss.html:202))
- replace unbound with success as null element in state ([profile/state.ss.html:206](https://github.com/emdonahue/aiKanren/blob/main/profile/state.ss.html:206))
- reify vars inside constraints ([profile/state.ss.html:210](https://github.com/emdonahue/aiKanren/blob/main/profile/state.ss.html:210))
- is there a good opportunity to further simplify constraints rechecked by unify using the other unifications we are performing during a complex unification? currently we only simplify constraints with the unification on the variable to which they are bound, but they might contain other variables that we could simplify now and then not have to walk to look up later. maybe we combine the list of unifications and the list of constraints after return from unify</span> ([profile/state.ss.html:263](https://github.com/emdonahue/aiKanren/blob/main/profile/state.ss.html:263))
- When should simplifying a constraint commit more ==?</span> ([profile/state.ss.html:273](https://github.com/emdonahue/aiKanren/blob/main/profile/state.ss.html:273))
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify</span> ([profile/state.ss.html:282](https://github.com/emdonahue/aiKanren/blob/main/profile/state.ss.html:282))
- simplifiers need more thorough testing</span> ([profile/state.ss.html:309](https://github.com/emdonahue/aiKanren/blob/main/profile/state.ss.html:309))
- consider only simplifying part of disj to guarantee that analyzed constraints attribute to the currently unified pair.</span> ([profile/state.ss.html:313](https://github.com/emdonahue/aiKanren/blob/main/profile/state.ss.html:313))
- how does disunify play with constraints in substitution?</span> ([profile/state.ss.html:325](https://github.com/emdonahue/aiKanren/blob/main/profile/state.ss.html:325))
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros</span> ([profile/state.ss.html:343](https://github.com/emdonahue/aiKanren/blob/main/profile/state.ss.html:343))
- consider sorting ids of variables before adding constraints to optimize adding to sbral</span> ([profile/state.ss.html:350](https://github.com/emdonahue/aiKanren/blob/main/profile/state.ss.html:350))
- clean up state add constraint. remove dead code</span> ([profile/state.ss.html:353](https://github.com/emdonahue/aiKanren/blob/main/profile/state.ss.html:353))
- rename unbind-constraint -&gt; remove-constraint</span> ([profile/state.ss.html:362](https://github.com/emdonahue/aiKanren/blob/main/profile/state.ss.html:362))
- delete datatypes.ss ([profile/datatypes.ss.html:338](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:338))
- replace conj-car/cdr with lhs/rhs ([profile/datatypes.ss.html:358](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:358))
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var ([profile/datatypes.ss.html:384](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:384))
- remove set-state-varid</span> ([profile/datatypes.ss.html:436](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:436))
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints ([profile/datatypes.ss.html:464](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:464))
- see if normalize-matcho adds anything to solve-matcho</span> ([profile/datatypes.ss.html:482](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:482))
- revisit goal-cond once fresh is either explicit or removed ([profile/datatypes.ss.html:496](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:496))
- replace conj with make-conj or short circuiting conj* where possible</span> ([profile/datatypes.ss.html:532](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:532))
- experiment with short circuiting conj and disj macros ([profile/datatypes.ss.html:539](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:539))
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns ([profile/datatypes.ss.html:540](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:540))
- remove conj-car</span> ([profile/datatypes.ss.html:556](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:556))
- is conj-fold ever used?</span> ([profile/datatypes.ss.html:586](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:586))
- convert constructor fns to constructed params of structure  </span> ([profile/datatypes.ss.html:595](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:595))
- microbenchmark disj cdr that looks ahead instead of using base case to check for non disj</span> ([profile/datatypes.ss.html:610](https://github.com/emdonahue/aiKanren/blob/main/profile/datatypes.ss.html:610))
- first order matcho that can be unified with a variable to destructure it. Useful for passing to functions where we dont have a reference to the variable ([profile/matcho.ss.html:150](https://github.com/emdonahue/aiKanren/blob/main/profile/matcho.ss.html:150))
- consider a way to give matcho a global identity (maybe baking it into a defrel form?) so that matcho constraints with the same payload can simplify one another. eg, calling absento with the same payload on subparts of the same list many times ([profile/matcho.ss.html:151](https://github.com/emdonahue/aiKanren/blob/main/profile/matcho.ss.html:151))
- integrate constraint substitutions with matcho ([profile/matcho.ss.html:161](https://github.com/emdonahue/aiKanren/blob/main/profile/matcho.ss.html:161))
- generalize matcho-pair to multiple pairs, pairs with constant patterns, and other common patterns such as a-list ([profile/matcho.ss.html:179](https://github.com/emdonahue/aiKanren/blob/main/profile/matcho.ss.html:179))
- specialize multiple pair matcho-pair on different modes (ground, free, etc) so we can always instantly destructure whatever is ground. may involve further manipulations of goal order based on mode ([profile/matcho.ss.html:181](https://github.com/emdonahue/aiKanren/blob/main/profile/matcho.ss.html:181))
- can we make a generalized matcho out of matcho-pair on each pair of a pattern? ([profile/matcho.ss.html:182](https://github.com/emdonahue/aiKanren/blob/main/profile/matcho.ss.html:182))
- specialize matcho for constraints vs goal &amp; let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) ([profile/matcho.ss.html:212](https://github.com/emdonahue/aiKanren/blob/main/profile/matcho.ss.html:212))
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts ([profile/matcho.ss.html:213](https://github.com/emdonahue/aiKanren/blob/main/profile/matcho.ss.html:213))
- if matcho out-vars do not appear in the body, is there is no need to apply occurs-check constraints?</span> ([profile/matcho.ss.html:217](https://github.com/emdonahue/aiKanren/blob/main/profile/matcho.ss.html:217))
- add fender to matcho to prevent duplicate lhs vars and cyclic pattern vars (since out-vars are bound beneath in-vars, so the shadowing will go the wrong way)</span> ([profile/matcho.ss.html:235](https://github.com/emdonahue/aiKanren/blob/main/profile/matcho.ss.html:235))
- equip matcho with the patterns externally to fail constraints without invoking goal. </span> ([profile/matcho.ss.html:238](https://github.com/emdonahue/aiKanren/blob/main/profile/matcho.ss.html:238))
- under what conditions should matcho continue?</span> ([profile/matcho.ss.html:249](https://github.com/emdonahue/aiKanren/blob/main/profile/matcho.ss.html:249))
- test for-eacho with xs^ shadowing xs once matcho identifiers are fixed</span> ([profile/listo.ss.html:105](https://github.com/emdonahue/aiKanren/blob/main/profile/listo.ss.html:105))
- does asspo need an extra argument to succeed if none found? eg disjoin with final goal?</span> ([profile/listo.ss.html:112](https://github.com/emdonahue/aiKanren/blob/main/profile/listo.ss.html:112))
- merge asspo matchos into single matcho once optimized</span> ([profile/listo.ss.html:113](https://github.com/emdonahue/aiKanren/blob/main/profile/listo.ss.html:113))
- can alist relations just be constraints if they only return 1 and use constraint semantics to terminate search?</span> ([profile/listo.ss.html:114](https://github.com/emdonahue/aiKanren/blob/main/profile/listo.ss.html:114))
- make goal-cond automatically add a condition for trace goals when not compiling and make trace goals vanish when compiling (test (optimize-level) param? ([profile/tracing.ss.html:238](https://github.com/emdonahue/aiKanren/blob/main/profile/tracing.ss.html:238))
- make all goals accept a list of states so that we can print only the code as written and the input and output states without having to multiplex the code points for the tracing interpreter ([profile/tracing.ss.html:252](https://github.com/emdonahue/aiKanren/blob/main/profile/tracing.ss.html:252))
- DRY the matcho/exist/fresh calls to common calling interface. maybe use =&gt; cond interface ([profile/tracing.ss.html:260](https://github.com/emdonahue/aiKanren/blob/main/profile/tracing.ss.html:260))
- might be able to fold proofs into standard dfs with parameters and get rid of special cps trace interpreter</span> ([profile/tracing.ss.html:278](https://github.com/emdonahue/aiKanren/blob/main/profile/tracing.ss.html:278))
- trim exports ([profile/solver.ss.html:239](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:239))
- should solve noto solve the positive goal with ctn and then simply transform the result somehow?</span> ([profile/solver.ss.html:268](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:268))
- scrutinize precisely which goals must be returned and which may solve further</span> ([profile/solver.ss.html:271](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:271))
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms</span> ([profile/solver.ss.html:276](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:276))
- quick replace extended vars in constraints looked up during unify and check for immediate failures</span> ([profile/solver.ss.html:277](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:277))
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail</span> ([profile/solver.ss.html:278](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:278))
- can we sort our conjunctions into those containing variables not touched by the current unifications and so may need to be further walked/solved and those that we can just directly strap on to the out parameter now? may have to do with analyzing which ones have disjunctions that are still normalized even after updates with current unifications</span> ([profile/solver.ss.html:279](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:279))
- we can construct the unified normalized goal as a binary tree no var ids and make it faster to use it as a mini substitution for further simplification</span> ([profile/solver.ss.html:280](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:280))
- add a non occurs check =!= or ==!</span> ([profile/solver.ss.html:288](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:288))
- can we pack eigen checks onto occurs check and get them for free?</span> ([profile/solver.ss.html:289](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:289))
- see if the normalized ==s can help speed up occurs-check, eg by only checking rhs terms in case of a trail of unified terms. maybe use the fact that normalized vars have directional unification?</span> ([profile/solver.ss.html:295](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:295))
- can we just add the =/= disjunction directly to the state and let the solver deal with it? might have to report it as added rather than pending once the two constraint return system is in place</span> ([profile/solver.ss.html:305](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:305))
- add patterns to matcho and check them in simplify-=/= </span> ([profile/solver.ss.html:334](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:334))
- push the diseq as far back as needed by giving it to the tail computation if we would otherwise append it before tail</span> ([profile/solver.ss.html:352](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:352))
- if disj1 contains no ==, and disj-tail fails, we do not need to recheck disj2</span> ([profile/solver.ss.html:360](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:360))
- replace walkvar in matcho solver with walk once matcho handles walks</span> ([profile/solver.ss.html:367](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:367))
- this walk should be handled by == when it replaces var with new binding</span> ([profile/solver.ss.html:368](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:368))
- if we get a non pair, we can fail matcho right away without expanding lambda</span> ([profile/solver.ss.html:369](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:369))
- just operate on the list for matcho solving</span> ([profile/solver.ss.html:373](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:373))
- add guard rails for pconstraints returning lowest form and further solving ([profile/solver.ss.html:389](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:389))
- solve-pconstraint really only needs to be called the first time. after that pconstraints solve themselves</span> ([profile/solver.ss.html:390](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:390))
- make store constraint put disj right and everything else left</span> ([profile/solver.ss.html:404](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:404))
- storing conj whole if lhs and rhs have same attributed vars. check attr vars of lhs and rhs. if same, pass to parent. when differ, store children independently</span> ([profile/solver.ss.html:409](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:409))
- thread trace-goal through other critical infrastructure so its semantically transparent ([profile/solver.ss.html:414](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:414))
- create a defrel that encodes context information about what vars were available for use in reasoning about which freshes might be able to unify them within their lexical scope</span> ([profile/solver.ss.html:416](https://github.com/emdonahue/aiKanren/blob/main/profile/solver.ss.html:416))
- remove mini-substitution ([profile/mini-substitution.ss.html:71](https://github.com/emdonahue/aiKanren/blob/main/profile/mini-substitution.ss.html:71))
- refactor this library into 'vars' and other ([profile/ui.ss.html:176](https://github.com/emdonahue/aiKanren/blob/main/profile/ui.ss.html:176))
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals ([profile/ui.ss.html:184](https://github.com/emdonahue/aiKanren/blob/main/profile/ui.ss.html:184))
- make conde do fail checks syntactically ([profile/ui.ss.html:193](https://github.com/emdonahue/aiKanren/blob/main/profile/ui.ss.html:193))
- make fresh-vars non-recursive ala matcho ([profile/ui.ss.html:301](https://github.com/emdonahue/aiKanren/blob/main/profile/ui.ss.html:301))
- look into making large con/disjunctions of the same variable gather into a binary tree or something other than a random list and automatically build a decent data structure for it</span> ([profile/constraints.ss.html:148](https://github.com/emdonahue/aiKanren/blob/main/profile/constraints.ss.html:148))
- try ==&gt; as =/=|== in case =/= might be more efficient for attribution/</span> ([profile/constraints.ss.html:151](https://github.com/emdonahue/aiKanren/blob/main/profile/constraints.ss.html:151))
- have typeo simplify == not simply succeed or fail</span> ([profile/constraints.ss.html:168](https://github.com/emdonahue/aiKanren/blob/main/profile/constraints.ss.html:168))
- create defconstraint that tags any matchos returned with the function pointer so they can dedup themselves</span> ([profile/constraints.ss.html:236](https://github.com/emdonahue/aiKanren/blob/main/profile/constraints.ss.html:236))
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times ([profile/store.ss.html:71](https://github.com/emdonahue/aiKanren/blob/main/profile/store.ss.html:71))
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them ([profile/store.ss.html:72](https://github.com/emdonahue/aiKanren/blob/main/profile/store.ss.html:72))
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers ([profile/store.ss.html:73](https://github.com/emdonahue/aiKanren/blob/main/profile/store.ss.html:73))
README.md:9:## TODO
- can we get guarded goal functionality by an == constraint and a schedule that when run unifies the guarded variables thereby triggering the unification? ([src/mk/aikanren.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/mk/aikanren.ss:1))
- do == and =/= automatically simplify when merged because we run constraints on the state not the substitution when reducing? ([src/mk/aikanren.ss:2](https://github.com/emdonahue/aiKanren/blob/main/src/mk/aikanren.ss:2))
- bool is just true or false. does this automatically gel with =/= of the other one? ([src/mk/aikanren.ss:3](https://github.com/emdonahue/aiKanren/blob/main/src/mk/aikanren.ss:3))
- we can get finite domain like ability to actually generate the answers by popping the constraint and treating it as a goal ([src/mk/aikanren.ss:4](https://github.com/emdonahue/aiKanren/blob/main/src/mk/aikanren.ss:4))
- test whether optimize level works for whole library ([src/mk/aikanren.ss:5](https://github.com/emdonahue/aiKanren/blob/main/src/mk/aikanren.ss:5))
- test for-eacho with xs^ shadowing xs once matcho identifiers are fixed ([src/mk/listo.ss:35](https://github.com/emdonahue/aiKanren/blob/main/src/mk/listo.ss:35))
- does asspo need an extra argument to succeed if none found? eg disjoin with final goal? ([src/mk/listo.ss:42](https://github.com/emdonahue/aiKanren/blob/main/src/mk/listo.ss:42))
- merge asspo matchos into single matcho once optimized ([src/mk/listo.ss:43](https://github.com/emdonahue/aiKanren/blob/main/src/mk/listo.ss:43))
- can alist relations just be constraints if they only return 1 and use constraint semantics to terminate search? ([src/mk/listo.ss:44](https://github.com/emdonahue/aiKanren/blob/main/src/mk/listo.ss:44))
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options ([src/mk/utils.ss:49](https://github.com/emdonahue/aiKanren/blob/main/src/mk/utils.ss:49))
- maybe fold org-tracing boolean into depth 0? ([src/mk/utils.ss:53](https://github.com/emdonahue/aiKanren/blob/main/src/mk/utils.ss:53))
- make org-lambda check for optimization and remove itself to improve performance with debugging infrastructure in place ([src/mk/utils.ss:106](https://github.com/emdonahue/aiKanren/blob/main/src/mk/utils.ss:106))
- simplify with negated pconstraints as well ([src/mk/reducer.ss:5](https://github.com/emdonahue/aiKanren/blob/main/src/mk/reducer.ss:5))
- if == simplifier can confirm disj-rhs wont fail, do we need to recheck it? maybe it already contains two disjuncts with == that wont need to be rechecked ([src/mk/reducer.ss:21](https://github.com/emdonahue/aiKanren/blob/main/src/mk/reducer.ss:21))
- in simplify matcho, can i just return the g case and let one fail be enough? ([src/mk/reducer.ss:57](https://github.com/emdonahue/aiKanren/blob/main/src/mk/reducer.ss:57))
- should we thread the real state when expanding matcho while reducing ==? ([src/mk/reducer.ss:59](https://github.com/emdonahue/aiKanren/blob/main/src/mk/reducer.ss:59))
- delete failure.ss ([src/mk/failure.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/mk/failure.ss:1))
- replace assert #f with useful error messages ([src/mk/goals.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:1))
- define a secondary run goal that runs children of conde and only that one should suspend fresh because it represents having to make a choice instead of pursuing a goal linearly into its depths ([src/mk/goals.ss:8](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:8))
- if we convert interleaving to cps, we can use the goal structure to store tracing info and trace the interleaving search without special affordances. might work if tracing goals just mutate rather than shadow params ([src/mk/goals.ss:9](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:9))
- if convert search to cps, can we use the results of walk to simplify the ctn and decide not to walk some of its goals? ([src/mk/goals.ss:10](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:10))
- do freshes that dont change the state preserve low varid count? ([src/mk/goals.ss:16](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:16))
- separate suspended into its own constraint and treat procedures as ad hoc goals to be run immediately. ad hoc goals that already guarantee normal form can simply return succeed and the new state/package ([src/mk/goals.ss:17](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:17))
- do freshes that dont change the state preserve low varid count? ([src/mk/goals.ss:18](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:18))
- check whether structural recursion check is needed anymore for matcho or if single state return is enough ([src/mk/goals.ss:25](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:25))
- move trace-goal to a procedure that checks for tracing params and only returns trace goal objects if tracing, otherwise noop and can remove from non tracing interpreters ([src/mk/goals.ss:33](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:33))
- use the ==s from constraints to simplify continuations in normal goal interpreter ([src/mk/goals.ss:34](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:34))
- consider making bind cps ([src/mk/goals.ss:49](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:49))
- consider analyzing goals in goal interpreter and running dfs if not recursive or only tail recursive. may require converting everything to cps. maybe use syntax analysis and a special conj type that marks its contents for dfs, where fresh bounces back to normal goal interpreter. it may not make a difference as outside of fresh a cps goal interpreter might be functionally depth first outside of trampolining ([src/mk/goals.ss:71](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:71))
- if we put run-goal-dfs in a parameter the tracing system will have a callback fn and we can trace without modifying the dfs ([src/mk/goals.ss:72](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:72))
- consider manipulating ctn order in dfs to get different searches, such as depth-ordered search using a functional queue to hold branching goals as the ctn ([src/mk/goals.ss:73](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:73))
- experiment with mutation-based mplus branch swap combined with answer return in one call ([src/mk/goals.ss:94](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:94))
- after optimizing matcho stopping only if branch detected, consider making that a merge point for a parallel execution where the other branch is put in the queue rather than an mplus ([src/mk/goals.ss:96](https://github.com/emdonahue/aiKanren/blob/main/src/mk/goals.ss:96))
- first order matcho that can be unified with a variable to destructure it. Useful for passing to functions where we dont have a reference to the variable ([src/mk/matcho.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss:1))
- consider a way to give matcho a global identity (maybe baking it into a defrel form?) so that matcho constraints with the same payload can simplify one another. eg, calling absento with the same payload on subparts of the same list many times ([src/mk/matcho.ss:2](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss:2))
- integrate constraint substitutions with matcho ([src/mk/matcho.ss:12](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss:12))
- generalize matcho-pair to multiple pairs, pairs with constant patterns, and other common patterns such as a-list ([src/mk/matcho.ss:30](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss:30))
- specialize multiple pair matcho-pair on different modes (ground, free, etc) so we can always instantly destructure whatever is ground. may involve further manipulations of goal order based on mode ([src/mk/matcho.ss:32](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss:32))
- can we make a generalized matcho out of matcho-pair on each pair of a pattern? ([src/mk/matcho.ss:33](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss:33))
- specialize matcho for constraints vs goal & let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) ([src/mk/matcho.ss:63](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss:63))
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts ([src/mk/matcho.ss:64](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss:64))
- if matcho out-vars do not appear in the body, is there is no need to apply occurs-check constraints? ([src/mk/matcho.ss:68](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss:68))
- allow matcho to match non pairs to allow constructing pairs from ground terms, and then =/= simplify should not fail on pairs for matcho ([src/mk/matcho.ss:88](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss:88))
- add fender to matcho to prevent duplicate lhs vars and cyclic pattern vars (since out-vars are bound beneath in-vars, so the shadowing will go the wrong way) ([src/mk/matcho.ss:90](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss:90))
- equip matcho with the patterns externally to fail constraints without invoking goal.  ([src/mk/matcho.ss:93](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss:93))
- under what conditions should matcho continue? ([src/mk/matcho.ss:104](https://github.com/emdonahue/aiKanren/blob/main/src/mk/matcho.ss:104))
- should minireify check eq or var? ([src/mk/mini-substitution.ss:59](https://github.com/emdonahue/aiKanren/blob/main/src/mk/mini-substitution.ss:59))
- double check state exports. remove extend at least ([src/mk/state.ss:2](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:2))
- replace unbound with success as null element in state ([src/mk/state.ss:6](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:6))
- reify vars inside constraints ([src/mk/state.ss:10](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:10))
- is there a good opportunity to further simplify constraints rechecked by unify using the other unifications we are performing during a complex unification? currently we only simplify constraints with the unification on the variable to which they are bound, but they might contain other variables that we could simplify now and then not have to walk to look up later. maybe we combine the list of unifications and the list of constraints after return from unify ([src/mk/state.ss:62](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:62))
- When should simplifying a constraint commit more ==? ([src/mk/state.ss:77](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:77))
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify ([src/mk/state.ss:86](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:86))
- unify should simplify constraints together as it conjoins them, or perhaps in solve-== after they have all been normalized ([src/mk/state.ss:92](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:92))
- return val constraint to simplify it with potentially other bindings and also unbind its var? ([src/mk/state.ss:102](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:102))
- if == simplifier can confirm disj-rhs wont fail, do we need to recheck it? maybe it already contains two disjuncts with == that wont need to be rechecked ([src/mk/state.ss:131](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:131))
- in simplify matcho, can i just return the g case and let one fail be enough? ([src/mk/state.ss:150](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:150))
- should we thread the real state when expanding matcho while simplifying ==? ([src/mk/state.ss:153](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:153))
- refactor pconstraint solving/simplifying to share var iteration code among impls ([src/mk/state.ss:159](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:159))
- make == simplifier for pconstraints check for new vars ([src/mk/state.ss:164](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:164))
- how does disunify play with constraints in substitution? ([src/mk/state.ss:175](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:175))
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros ([src/mk/state.ss:194](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:194))
- consider sorting ids of variables before adding constraints to optimize adding to sbral. or possibly writing an sbral multi-add that does one pass and adds everything. would work well with sorted lists of attr vars to compare which constraints we can combine while adding ([src/mk/state.ss:201](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:201))
- can we store stale constraints? ([src/mk/state.ss:222](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:222))
- clean up state add constraint. remove dead code ([src/mk/state.ss:224](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:224))
- rename unbind-constraint -> remove-constraint ([src/mk/state.ss:233](https://github.com/emdonahue/aiKanren/blob/main/src/mk/state.ss:233))
- delete datatypes.ss ([src/mk/datatypes.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:1))
- replace conj-car/cdr with lhs/rhs ([src/mk/datatypes.ss:21](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:21))
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var ([src/mk/datatypes.ss:49](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:49))
- try replacing state vector copy with manual updates using mutators ([src/mk/datatypes.ss:102](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:102))
- remove set-state-varid ([src/mk/datatypes.ss:121](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:121))
- rename state-or-failure? to maybe-state? ([src/mk/datatypes.ss:127](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:127))
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints. also break two pairs into a conj of ==. then we can simplify the order checking inside the unifier ([src/mk/datatypes.ss:149](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:149))
- see if normalize-matcho adds anything to solve-matcho ([src/mk/datatypes.ss:168](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:168))
- revisit goal-cond once fresh is either explicit or removed ([src/mk/datatypes.ss:198](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:198))
- replace conj with make-conj or short circuiting conj* where possible ([src/mk/datatypes.ss:234](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:234))
- experiment with short circuiting conj and disj macros ([src/mk/datatypes.ss:243](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:243))
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns ([src/mk/datatypes.ss:244](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:244))
- remove conj-car ([src/mk/datatypes.ss:260](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:260))
- is conj-fold ever used? ([src/mk/datatypes.ss:292](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:292))
- convert constructor fns to constructed params of structure   ([src/mk/datatypes.ss:302](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:302))
- microbenchmark disj cdr that looks ahead instead of using base case to check for non disj ([src/mk/datatypes.ss:318](https://github.com/emdonahue/aiKanren/blob/main/src/mk/datatypes.ss:318))
- look into making large con/disjunctions of the same variable gather into a binary tree or something other than a random list and automatically build a decent data structure for it ([src/mk/constraints.ss:8](https://github.com/emdonahue/aiKanren/blob/main/src/mk/constraints.ss:8))
- try ==> as =/=|== in case =/= might be more efficient for attribution/ ([src/mk/constraints.ss:12](https://github.com/emdonahue/aiKanren/blob/main/src/mk/constraints.ss:12))
- do constraints need to manage recheck individually or is that just for matcho and disj? ([src/mk/constraints.ss:27](https://github.com/emdonahue/aiKanren/blob/main/src/mk/constraints.ss:27))
- have typeo simplify == not simply succeed or fail ([src/mk/constraints.ss:38](https://github.com/emdonahue/aiKanren/blob/main/src/mk/constraints.ss:38))
- create defconstraint that tags any matchos returned with the function pointer so they can dedup themselves ([src/mk/constraints.ss:107](https://github.com/emdonahue/aiKanren/blob/main/src/mk/constraints.ss:107))
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail ([src/mk/solver.ss:55](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:55))
- if we only get 1 binding in solve-==, it has already been simplified inside unify and we can skip it ([src/mk/solver.ss:56](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:56))
- can we simplify committed/pending as well and simplify already committed constraints from lower in the computation? ([src/mk/solver.ss:57](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:57))
- see if the normalized ==s can help speed up occurs-check/binding, eg by only checking rhs terms in case of a trail of unified terms. maybe use the fact that normalized vars have directional unification? ([src/mk/solver.ss:86](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:86))
- try implementing occurs check in the constraint system and eliminating checks in the wrong id direction (eg only check lower->higher) ([src/mk/solver.ss:87](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:87))
- add a non occurs check =!= or ==! ([src/mk/solver.ss:88](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:88))
- add flag to let solve-disj know that its constraint might be normalized and to skip initial solving ([src/mk/solver.ss:103](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:103))
- is mini-unify necessary in solve-disj since the constraints should be normalized so we don't have two pairs? ([src/mk/solver.ss:118](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:118))
- add patterns to matcho and check them in simplify-=/= ([src/mk/solver.ss:126](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:126))
- replace walkvar in matcho solver with walk once matcho handles walks ([src/mk/solver.ss:171](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:171))
- this walk should be handled by == when it replaces var with new binding ([src/mk/solver.ss:172](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:172))
- if we get a non pair, we can fail matcho right away without expanding lambda ([src/mk/solver.ss:173](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:173))
- just operate on the list for matcho solving ([src/mk/solver.ss:177](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:177))
- split g in solve-disj into normalized and unnormalized args to let other fns flexibly avoid double solving already normalized constraints ([src/mk/solver.ss:180](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:180))
- deal with non left branching disjs that may be created dynamically by =/= or matcho. fundamentally we have to thread information from the first disj through to others and treat them linearly ([src/mk/solver.ss:185](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:185))
- can we just stash the pconstraint with the simplified under certain conditions if we know it wont need further solving? ([src/mk/solver.ss:207](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:207))
- make store constraint put disj right and everything else left ([src/mk/solver.ss:278](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:278))
- storing conj whole if lhs and rhs have same attributed vars. check attr vars of lhs and rhs. if same, pass to parent. when differ, store children independently ([src/mk/solver.ss:284](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:284))
- thread trace-goal through other critical infrastructure so its semantically transparent ([src/mk/solver.ss:289](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:289))
- create a defrel that encodes context information about what vars were available for use in reasoning about which freshes might be able to unify them within their lexical scope ([src/mk/solver.ss:291](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:291))
- do we need to check for recheckable matchos when attributing disj? ([src/mk/solver.ss:297](https://github.com/emdonahue/aiKanren/blob/main/src/mk/solver.ss:297))
- Abstract out some of the math checks for navigating sbral ([src/mk/sbral.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/mk/sbral.ss:1))
- put the 0 somewhere else so sbral is more aesthetic when printed ([src/mk/sbral.ss:10](https://github.com/emdonahue/aiKanren/blob/main/src/mk/sbral.ss:10))
- can sbral reference walk back up the list on the return from the recursion and rerecurse into nodes it visits along the way because early vars will always point to later vars? ([src/mk/sbral.ss:26](https://github.com/emdonahue/aiKanren/blob/main/src/mk/sbral.ss:26))
- create special purpose upsert fns in sbral that let us set and conjoin a new constraint in one operation ([src/mk/sbral.ss:32](https://github.com/emdonahue/aiKanren/blob/main/src/mk/sbral.ss:32))
- optimize sbral->alist/sbral->list ([src/mk/sbral.ss:77](https://github.com/emdonahue/aiKanren/blob/main/src/mk/sbral.ss:77))
- refactor this library into 'vars' and other ([src/mk/ui.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/mk/ui.ss:1))
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals ([src/mk/ui.ss:10](https://github.com/emdonahue/aiKanren/blob/main/src/mk/ui.ss:10))
- make conde do fail checks syntactically ([src/mk/ui.ss:19](https://github.com/emdonahue/aiKanren/blob/main/src/mk/ui.ss:19))
- make fresh-vars non-recursive ala matcho ([src/mk/ui.ss:132](https://github.com/emdonahue/aiKanren/blob/main/src/mk/ui.ss:132))
- make goal-cond automatically add a condition for trace goals when not compiling and make trace goals vanish when compiling (test (optimize-level) param? ([src/mk/tracing.ss:14](https://github.com/emdonahue/aiKanren/blob/main/src/mk/tracing.ss:14))
- make all goals accept a list of states so that we can print only the code as written and the input and output states without having to multiplex the code points for the tracing interpreter ([src/mk/tracing.ss:30](https://github.com/emdonahue/aiKanren/blob/main/src/mk/tracing.ss:30))
- DRY the matcho/exist/fresh calls to common calling interface. maybe use => cond interface ([src/mk/tracing.ss:39](https://github.com/emdonahue/aiKanren/blob/main/src/mk/tracing.ss:39))
- might be able to fold proofs into standard dfs with parameters and get rid of special cps trace interpreter ([src/mk/tracing.ss:58](https://github.com/emdonahue/aiKanren/blob/main/src/mk/tracing.ss:58))
- print unbound variables in substitution debugging by checking var id in state ([src/mk/tracing.ss:149](https://github.com/emdonahue/aiKanren/blob/main/src/mk/tracing.ss:149))
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times ([src/mk/store.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/mk/store.ss:1))
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them ([src/mk/store.ss:2](https://github.com/emdonahue/aiKanren/blob/main/src/mk/store.ss:2))
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers ([src/mk/store.ss:3](https://github.com/emdonahue/aiKanren/blob/main/src/mk/store.ss:3))
- determine whether bind should halt after every fresh or only those that generate mplus/binds ([src/tests/goal-tests.ss:40](https://github.com/emdonahue/aiKanren/blob/main/src/tests/goal-tests.ss:40))
- test reify cyclic once unsound unification implemented ([src/tests/goal-tests.ss:59](https://github.com/emdonahue/aiKanren/blob/main/src/tests/goal-tests.ss:59))
- make  ([src/tests/goal-tests.ss:61](https://github.com/emdonahue/aiKanren/blob/main/src/tests/goal-tests.ss:61))
- can we simplify disjunctions of == and =/= of the same var? technically should be simplified to x1 =/= 1 ([src/tests/solver-tests.ss:64](https://github.com/emdonahue/aiKanren/blob/main/src/tests/solver-tests.ss:64))
- revisit matcho eagerness if all ground ([src/tests/matcho-tests.ss:26](https://github.com/emdonahue/aiKanren/blob/main/src/tests/matcho-tests.ss:26))
- make tassert capture file and line number ([src/tests/test-runner.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/tests/test-runner.ss:1))
- test multi-success disj that should succeed instead of suspending as constraint. maybe normalize before starting constraint walk. maybe already handled by normalizing resulting constraint ([src/tests/constraints-tests.ss:1](https://github.com/emdonahue/aiKanren/blob/main/src/tests/constraints-tests.ss:1))
- test that recursive disjunctions containing unifications dont run forever looking for a case that doesn't involve == when attributing/solving disjunctions ([src/tests/constraints-tests.ss:285](https://github.com/emdonahue/aiKanren/blob/main/src/tests/constraints-tests.ss:285))
- quote/literal only needed if atoms in the output do not appear in the input ([src/examples/interpreter.ss:37](https://github.com/emdonahue/aiKanren/blob/main/src/examples/interpreter.ss:37))
- can lookup be a constraint? ([src/examples/interpreter.ss:62](https://github.com/emdonahue/aiKanren/blob/main/src/examples/interpreter.ss:62))
- enable environment variables in patterns with unquote ([src/examples/interpreter.ss:72](https://github.com/emdonahue/aiKanren/blob/main/src/examples/interpreter.ss:72))
- can we use first order matcho to eliminate need for exist? ([src/examples/interpreter.ss:84](https://github.com/emdonahue/aiKanren/blob/main/src/examples/interpreter.ss:84))
- can lookup be a constraint? ([src/examples/quine.ss:29](https://github.com/emdonahue/aiKanren/blob/main/src/examples/quine.ss:29))
- enable environment variables in patterns with unquote ([src/examples/quine.ss:35](https://github.com/emdonahue/aiKanren/blob/main/src/examples/quine.ss:35))
- merge optimized matchos ([src/examples/quine.ss:61](https://github.com/emdonahue/aiKanren/blob/main/src/examples/quine.ss:61))
