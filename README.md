# aiKanren
A miniKanren implementation designed to serve as a platform for AI research combining logical and probabilistic reasoning.

## Documentation
## Not Yet Implemented
-  'y-goal-disunify (src/aikanren/state.ss:157)
## TODO
- can we get guarded goal functionality by an == constraint and a schedule that when run unifies the guarded variables thereby triggering the unification? (build/object/aikanren.ss:1)
- do == and =/= automatically simplify when merged because we run constraints on the state not the substitution when reducing? (build/object/aikanren.ss:2)
- bool is just true or false. does this automatically gel with =/= of the other one? (build/object/aikanren.ss:3)
- we can get finite domain like ability to actually generate the answers by popping the constraint and treating it as a goal (build/object/aikanren.ss:4)
- test whether optimize level works for whole library (build/object/aikanren.ss:5)
- remove runner lib (build/object/runner.ss:1)
- delete failure.ss (build/object/failure.ss:1)
- replace assert #f with useful error messages (build/object/goals.ss:1)
- trim exports (build/object/goals.ss:3)
- do freshes that dont change the state preserve low varid count? (build/object/goals.ss:11)
- generalize matcho-pair to multiple pairs, pairs with constant patterns, and other common patterns such as a-list (build/object/matcho.ss:28)
- specialize matcho for constraints vs goal & let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) (build/object/matcho.ss:54)
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts (build/object/matcho.ss:55)
- add fender to matcho to prevent duplicate lhs vars (build/object/matcho.ss:74)
- equip matcho with the patterns externally to fail constraints without invoking goal.  (build/object/matcho.ss:77)
- remove mini-substitution (build/object/mini-substitution.ss:1)
- double check state exports. remove extend at least (build/object/state.ss:2)
- support cyclic terms in reifier (build/object/state.ss:11)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (build/object/state.ss:52)
- make unifier normalize? (build/object/state.ss:58)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (build/object/state.ss:95)
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros (build/object/state.ss:98)
- delete datatypes.ss (build/object/datatypes.ss:1)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (build/object/datatypes.ss:45)
- microbenchmark fxvector for var (build/object/datatypes.ss:46)
- microbenchmark var-equal? vs fx= (build/object/datatypes.ss:47)
- remove set-state-varid (build/object/datatypes.ss:89)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (build/object/datatypes.ss:116)
- see if normalize-matcho adds anything to solve-matcho (build/object/datatypes.ss:132)
- revisit goal-cond once fresh is either explicit or removed (build/object/datatypes.ss:139)
- replace conj with make-conj or short circuiting conj* where possible (build/object/datatypes.ss:158)
- experiment with short circuiting conj and disj macros (build/object/datatypes.ss:165)
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns (build/object/datatypes.ss:166)
- is conj-fold ever used? (build/object/datatypes.ss:195)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms (build/object/solver.ss:35)
- quick replace extended vars in constraints looked up during unify and check for immediate failures (build/object/solver.ss:36)
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail (build/object/solver.ss:37)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere. However, these may nevertheless trigger unification on that var (build/object/solver.ss:54)
- let solve constraint handle fail case (build/object/solver.ss:61)
- this walk should be handled by == when it replaces var with new binding (build/object/solver.ss:78)
- just operate on the list for matcho solving (build/object/solver.ss:83)
- delete extracted == from disj clauses (build/object/solver.ss:89)
- make diff-== just a list. no need to dedup because we are dredging normalized output (build/object/solver.ss:105)
- succeed should probably skip any computations in diff-== (build/object/solver.ss:106)
- storing conj whole if lhs and rhs have same attributed vars (build/object/solver.ss:147)
- reevaluate inverting disj given that they are now binary (build/object/solver.ss:151)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (build/object/solver.ss:154)
- optimize which disj constraint we pick for attribution to minimize free vars (build/object/solver.ss:165)
- if we are checking 2 disjuncts, do we need both attr vars? (build/object/solver.ss:168)
- Abstract out some of the math checks for navigating sbral (build/object/sbral.ss:1)
- put the 0 somewhere else so sbral is more aesthetic when printed (build/object/sbral.ss:10)
- make conde expand syntactically (build/object/ui.ss:5)
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals (build/object/ui.ss:11)
- make fresh-vars non-recursive ala matcho (build/object/ui.ss:69)
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (build/object/store.ss:1)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (build/object/store.ss:2)
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers (build/object/store.ss:3)
- can we get guarded goal functionality by an == constraint and a schedule that when run unifies the guarded variables thereby triggering the unification? (build/preprocessed/aikanren.ss:1)
- do == and =/= automatically simplify when merged because we run constraints on the state not the substitution when reducing? (build/preprocessed/aikanren.ss:2)
- bool is just true or false. does this automatically gel with =/= of the other one? (build/preprocessed/aikanren.ss:3)
- we can get finite domain like ability to actually generate the answers by popping the constraint and treating it as a goal (build/preprocessed/aikanren.ss:4)
- test whether optimize level works for whole library (build/preprocessed/aikanren.ss:5)
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options (build/preprocessed/utils.ss:26)
- remove runner lib (build/preprocessed/runner.ss:1)
- delete failure.ss (build/preprocessed/failure.ss:1)
- replace assert #f with useful error messages (build/preprocessed/goals.ss:1)
- trim exports (build/preprocessed/goals.ss:3)
- do freshes that dont change the state preserve low varid count? (build/preprocessed/goals.ss:11)
- generalize matcho-pair to multiple pairs, pairs with constant patterns, and other common patterns such as a-list (build/preprocessed/matcho.ss:28)
- specialize matcho for constraints vs goal & let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) (build/preprocessed/matcho.ss:54)
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts (build/preprocessed/matcho.ss:55)
- add fender to matcho to prevent duplicate lhs vars (build/preprocessed/matcho.ss:74)
- equip matcho with the patterns externally to fail constraints without invoking goal.  (build/preprocessed/matcho.ss:77)
- remove mini-substitution (build/preprocessed/mini-substitution.ss:1)
- double check state exports. remove extend at least (build/preprocessed/state.ss:2)
- support cyclic terms in reifier (build/preprocessed/state.ss:11)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (build/preprocessed/state.ss:52)
- make unifier normalize? (build/preprocessed/state.ss:58)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (build/preprocessed/state.ss:95)
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros (build/preprocessed/state.ss:98)
- delete datatypes.ss (build/preprocessed/datatypes.ss:1)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (build/preprocessed/datatypes.ss:45)
- microbenchmark fxvector for var (build/preprocessed/datatypes.ss:46)
- microbenchmark var-equal? vs fx= (build/preprocessed/datatypes.ss:47)
- remove set-state-varid (build/preprocessed/datatypes.ss:89)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (build/preprocessed/datatypes.ss:116)
- see if normalize-matcho adds anything to solve-matcho (build/preprocessed/datatypes.ss:132)
- revisit goal-cond once fresh is either explicit or removed (build/preprocessed/datatypes.ss:139)
- replace conj with make-conj or short circuiting conj* where possible (build/preprocessed/datatypes.ss:158)
- experiment with short circuiting conj and disj macros (build/preprocessed/datatypes.ss:165)
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns (build/preprocessed/datatypes.ss:166)
- is conj-fold ever used? (build/preprocessed/datatypes.ss:195)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms (build/preprocessed/solver.ss:35)
- quick replace extended vars in constraints looked up during unify and check for immediate failures (build/preprocessed/solver.ss:36)
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail (build/preprocessed/solver.ss:37)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere. However, these may nevertheless trigger unification on that var (build/preprocessed/solver.ss:54)
- let solve constraint handle fail case (build/preprocessed/solver.ss:61)
- this walk should be handled by == when it replaces var with new binding (build/preprocessed/solver.ss:78)
- just operate on the list for matcho solving (build/preprocessed/solver.ss:83)
- delete extracted == from disj clauses (build/preprocessed/solver.ss:89)
- make diff-== just a list. no need to dedup because we are dredging normalized output (build/preprocessed/solver.ss:105)
- succeed should probably skip any computations in diff-== (build/preprocessed/solver.ss:106)
- storing conj whole if lhs and rhs have same attributed vars (build/preprocessed/solver.ss:147)
- reevaluate inverting disj given that they are now binary (build/preprocessed/solver.ss:151)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (build/preprocessed/solver.ss:154)
- optimize which disj constraint we pick for attribution to minimize free vars (build/preprocessed/solver.ss:165)
- if we are checking 2 disjuncts, do we need both attr vars? (build/preprocessed/solver.ss:168)
- Abstract out some of the math checks for navigating sbral (build/preprocessed/sbral.ss:1)
- put the 0 somewhere else so sbral is more aesthetic when printed (build/preprocessed/sbral.ss:10)
- make conde expand syntactically (build/preprocessed/ui.ss:5)
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals (build/preprocessed/ui.ss:11)
- make fresh-vars non-recursive ala matcho (build/preprocessed/ui.ss:69)
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (build/preprocessed/store.ss:1)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (build/preprocessed/store.ss:2)
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers (build/preprocessed/store.ss:3)
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options (profile/utils.ss.html:149)
- replace assert #f with useful error messages (profile/goals.ss.html:93)
- trim exports (profile/goals.ss.html:95)
- do freshes that dont change the state preserve low varid count?</span> (profile/goals.ss.html:103)
- Abstract out some of the math checks for navigating sbral (profile/sbral.ss.html:115)
- put the 0 somewhere else so sbral is more aesthetic when printed (profile/sbral.ss.html:124)
- double check state exports (profile/state.ss.html:116)
- support cyclic terms in reifier</span> (profile/state.ss.html:125)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify</span> (profile/state.ss.html:158)
- make unifier normalize?</span> (profile/state.ss.html:164)
- delete datatypes.ss (profile/datatypes.ss.html:265)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (profile/datatypes.ss.html:309)
- remove set-state-varid</span> (profile/datatypes.ss.html:352)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (profile/datatypes.ss.html:379)
- see if normalize-matcho adds anything to solve-matcho</span> (profile/datatypes.ss.html:395)
- delete goal-cond (profile/datatypes.ss.html:401)
- replace conj with make-conj or short circuiting conj* where possible</span> (profile/datatypes.ss.html:418)
- evaluate divergence avoidance in conj goals</span> (profile/datatypes.ss.html:423)
- is conj-fold ever used?</span> (profile/datatypes.ss.html:442)
- specialize matcho for constraints vs goal &amp; let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) (profile/matcho.ss.html:136)
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts (profile/matcho.ss.html:137)
- add fender to matcho to prevent duplicate lhs vars</span> (profile/matcho.ss.html:153)
- equip matcho with the patterns externally to fail constraints without invoking goal. </span> (profile/matcho.ss.html:156)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms</span> (profile/solver.ss.html:264)
- quick replace extended vars in constraints looked up during unify and check for immediate failures</span> (profile/solver.ss.html:265)
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail</span> (profile/solver.ss.html:266)
- disunification unifier can be small step: we nly need to know 1 =/= succeeds before proceeding with search</span> (profile/solver.ss.html:275)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere</span> (profile/solver.ss.html:285)
- this walk should be handled by == when it replaces var with new binding</span> (profile/solver.ss.html:307)
- just operate on the list for matcho solving (profile/solver.ss.html:312)
- delete extracted == from disj clauses</span> (profile/solver.ss.html:318)
- make diff-== just a list. no need to dedup because we are dredging normalized output</span> (profile/solver.ss.html:334)
- succeed should probably skip any computations in diff-==</span> (profile/solver.ss.html:335)
- consider reversing constraint storage to put old constraints first</span> (profile/solver.ss.html:376)
- reevaluate inverting disj given that they are now binary (profile/solver.ss.html:380)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (profile/solver.ss.html:383)
- optimize which disj constraint we pick for attribution to minimize free vars</span> (profile/solver.ss.html:394)
- if we are checking 2 disjuncts, do we need both attr vars?</span> (profile/solver.ss.html:397)
- remove mini-substitution (profile/mini-substitution.ss.html:70)
- make conde expand syntactically (profile/ui.ss.html:124)
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals (profile/ui.ss.html:130)
- make fresh-vars non-recursive ala matcho (profile/ui.ss.html:189)
- make typo reject immediately if ground term not a type</span> (profile/constraints.ss.html:166)
profile/constraints.ss.html:242:		  <span class=pc4 title="line 100 char 3 count 99,197">;TODO(printf "A: ~s D: ~s~%" a d)</span>
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (profile/store.ss.html:71)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (profile/store.ss.html:72)
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers (profile/store.ss.html:73)
README.md:7:## TODO
- can we get guarded goal functionality by an == constraint and a schedule that when run unifies the guarded variables thereby triggering the unification? (src/aikanren/aikanren.ss:1)
- do == and =/= automatically simplify when merged because we run constraints on the state not the substitution when reducing? (src/aikanren/aikanren.ss:2)
- bool is just true or false. does this automatically gel with =/= of the other one? (src/aikanren/aikanren.ss:3)
- we can get finite domain like ability to actually generate the answers by popping the constraint and treating it as a goal (src/aikanren/aikanren.ss:4)
- test whether optimize level works for whole library (src/aikanren/aikanren.ss:5)
- look at https://github.com/cisco/ChezScheme/issues/128 for discussion of other tracing options (src/aikanren/utils.ss:34)
- make logging print lazily only if you log something at that trace level (src/aikanren/utils.ss:75)
- remove runner lib (src/aikanren/runner.ss:1)
- delete failure.ss (src/aikanren/failure.ss:1)
- replace assert #f with useful error messages (src/aikanren/goals.ss:1)
- trim exports (src/aikanren/goals.ss:3)
- do freshes that dont change the state preserve low varid count? (src/aikanren/goals.ss:12)
- experiment with mutation-based mplus branch swap combined with answer return in one call (src/aikanren/goals.ss:49)
- generalize matcho-pair to multiple pairs, pairs with constant patterns, and other common patterns such as a-list (src/aikanren/matcho.ss:28)
- specialize multiple pair matcho-pair on different modes (ground, free, etc) so we can always instantly destructure whatever is ground. may involve further manipulations of goal order based on mode (src/aikanren/matcho.ss:30)
- can we make a generalized matcho out of matcho-pair on each pair of a pattern? (src/aikanren/matcho.ss:31)
- specialize matcho for constraints vs goal & let interpreter decide implementation. constraint never needs to make fresh vars, goal doesn't need to know which vars are free (just whether) (src/aikanren/matcho.ss:54)
- can we fire matcho immediately if its structural recursion instead of waiting on a conjunct ahead of it that may be all free? reordering conjuncts (src/aikanren/matcho.ss:55)
- add fender to matcho to prevent duplicate lhs vars (src/aikanren/matcho.ss:74)
- equip matcho with the patterns externally to fail constraints without invoking goal.  (src/aikanren/matcho.ss:77)
- remove mini-substitution (src/aikanren/mini-substitution.ss:1)
- double check state exports. remove extend at least (src/aikanren/state.ss:2)
- support cyclic terms in reifier (src/aikanren/state.ss:11)
- is there a good opportunity to further simplify constraints rechecked by unify using the other unifications we are performing during a complex unification? currently we only simplify constraints with the unification on the variable to which they are bound, but they might contain other variables that we could simplify now and then not have to walk to look up later. maybe we combine the list of unifications and the list of constraints after return from unify (src/aikanren/state.ss:50)
- When should simplifying a constraint commit more ==? (src/aikanren/state.ss:61)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (src/aikanren/state.ss:73)
- make unifier normalize? (src/aikanren/state.ss:79)
- clean up state add constraint. remove dead code (src/aikanren/state.ss:130)
- rename unbind-constraint -> remove-constraint (src/aikanren/state.ss:139)
- how does disunify play with constraints in substitution? (src/aikanren/state.ss:146)
- can we extract only the subgoals that may unify when solving a =/= in disunify (src/aikanren/state.ss:155)
- test swapping var-equal? with another fx> check and making it the else case (src/aikanren/state.ss:163)
- test whether eq checking the returned terms and just returning the pair as is without consing a new one boosts performance in unify (src/aikanren/state.ss:168)
- test whether all the manual checks for fail/succeed could be replaced by conj/disj macros (src/aikanren/state.ss:171)
- delete datatypes.ss (src/aikanren/datatypes.ss:1)
- replace conj-car/cdr with lhs/rhs (src/aikanren/datatypes.ss:21)
- make the var tag a unique object to avoid unifying with a (var _) vector and confusing it for a real var (src/aikanren/datatypes.ss:46)
- microbenchmark fxvector for var (src/aikanren/datatypes.ss:47)
- get rid of var-equal? (src/aikanren/datatypes.ss:48)
- remove set-state-varid (src/aikanren/datatypes.ss:94)
- ensure that if two vars are unified, there is a definite order even in the goal so that we can read the rhs as always the 'value' when running constraints (src/aikanren/datatypes.ss:122)
- see if normalize-matcho adds anything to solve-matcho (src/aikanren/datatypes.ss:138)
- revisit goal-cond once fresh is either explicit or removed (src/aikanren/datatypes.ss:145)
- replace conj with make-conj or short circuiting conj* where possible (src/aikanren/datatypes.ss:164)
- experiment with short circuiting conj and disj macros (src/aikanren/datatypes.ss:172)
- make conj a macro but when it is just an identifier macro make it return a function of itself for use with higher order fns (src/aikanren/datatypes.ss:173)
- is conj-fold ever used? (src/aikanren/datatypes.ss:209)
- have typeo simplify == not simply succeed or fail (src/aikanren/constraints.ss:33)
- is it possible to use the delta on == as a minisubstitution and totally ignore the full substitution when checking constraints? maybe we only have to start doing walks when we reach the simplification level where vars wont be in lowest terms (src/aikanren/solver.ss:38)
- quick replace extended vars in constraints looked up during unify and check for immediate failures (src/aikanren/solver.ss:39)
- consider making occurs check a goal that we can append in between constraints we find and the rest of the ctn, so it only walks if constraints dont fail (src/aikanren/solver.ss:40)
- let solve constraint handle fail case (src/aikanren/solver.ss:57)
- =/= may not need to fire all the constraints conjoined to a given attributed var. maybe only grab a subset with == in them somewhere. However, these may nevertheless trigger unification on that var (src/aikanren/solver.ss:63)
- let solve constraint handle fail case (src/aikanren/solver.ss:70)
- this walk should be handled by == when it replaces var with new binding (src/aikanren/solver.ss:79)
- just operate on the list for matcho solving (src/aikanren/solver.ss:84)
- delete extracted == from disj clauses (src/aikanren/solver.ss:91)
- make diff-== just a list. no need to dedup because we are dredging normalized output (src/aikanren/solver.ss:108)
- succeed should probably skip any computations in diff-== (src/aikanren/solver.ss:109)
- remove guardo (src/aikanren/solver.ss:123)
- add guard rails for pconstraints returning lowest form and further solving (src/aikanren/solver.ss:131)
- storing conj whole if lhs and rhs have same attributed vars (src/aikanren/solver.ss:163)
- reevaluate inverting disj given that they are now binary (src/aikanren/solver.ss:167)
- perhaps instead of a fully inverted disj constraint pair we can simply add a dummy proxy constraint that if looked up succeeds but raises the constraint waiting on the original vars (src/aikanren/solver.ss:170)
- optimize which disj constraint we pick for attribution to minimize free vars (src/aikanren/solver.ss:181)
- if we are checking 2 disjuncts, do we need both attr vars? (src/aikanren/solver.ss:185)
- Abstract out some of the math checks for navigating sbral (src/aikanren/sbral.ss:1)
- put the 0 somewhere else so sbral is more aesthetic when printed (src/aikanren/sbral.ss:10)
- make conde expand syntactically (src/aikanren/ui.ss:5)
- make fresh insert fail checks between conjuncts to short circuit even building subsequent goals (src/aikanren/ui.ss:11)
- make fresh-vars non-recursive ala matcho (src/aikanren/ui.ss:69)
- perhaps all constraint lookups receive pointers to a single store so that we can cheeply copy pointers to different attributed variables but only remove and apply the constraint once instead of copying the constraint and applying it many times (src/aikanren/store.ss:1)
- == and =/= have different attributed variables, so each variable should store two lists. moreover, == are a superset of =/= so == list can just store the diff and then append them (src/aikanren/store.ss:2)
- if we have a central constraint lookup with pointers, some constraints will simplify in place and so we can add them back with the same pointer without updating other pointers, while some will generate new constraints that need to be assigned to new pointers. we can perhaps diff the new and old constraints and only add to new pointers (src/aikanren/store.ss:3)
- check that attr vars for diseq should be first 2 vs 1 (src/tests/solver-tests.ss:93)
- make tassert capture file and line number (src/tests/test-runner.ss:1)
- test multi-success disj that should succeed instead of suspending as constraint. maybe normalize before starting constraint walk. maybe already handled by normalizing resulting constraint (src/tests/constraints-tests.ss:1)
