(begin

  (bench "disequality - lookup" 1000
         ;; Raw constraint store extension speed
         ;; Because constraints and bound variables are mutually exclusive, we can store first-order constraints directly in the substitution and remove the need for a separate constraint store entirely. This lets us skip several walks as in walking the variable we simultaneously get any free variables to which it is bound as well as its constraint.
         (run -1 (x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 x51 x52 x53 x54 x55 x56 x57 x58 x59 x60 x61 x62 x63 x64 x65 x66 x67 x68 x69 x70 x71 x72 x73 x74 x75 x76 x77 x78 x79 x80 x81 x82 x83 x84 x85 x86 x87 x88 x89 x90 x91 x92 x93 x94 x95 x96 x97 x98 x99 x100)
           (=/= x1 1) (=/= x2 2) (=/= x3 3) (=/= x4 4) (=/= x5 5) (=/= x6 6) (=/= x7 7) (=/= x8 8) (=/= x9 9) (=/= x10 10) (=/= x11 11) (=/= x12 12) (=/= x13 13) (=/= x14 14) (=/= x15 15) (=/= x16 16) (=/= x17 17) (=/= x18 18) (=/= x19 19) (=/= x20 20) (=/= x21 21) (=/= x22 22) (=/= x23 23) (=/= x24 24) (=/= x25 25) (=/= x26 26) (=/= x27 27) (=/= x28 28) (=/= x29 29) (=/= x30 30) (=/= x31 31) (=/= x32 32) (=/= x33 33) (=/= x34 34) (=/= x35 35) (=/= x36 36) (=/= x37 37) (=/= x38 38) (=/= x39 39) (=/= x40 40) (=/= x41 41) (=/= x42 42) (=/= x43 43) (=/= x44 44) (=/= x45 45) (=/= x46 46) (=/= x47 47) (=/= x48 48) (=/= x49 49) (=/= x50 50) (=/= x51 51) (=/= x52 52) (=/= x53 53) (=/= x54 54) (=/= x55 55) (=/= x56 56) (=/= x57 57) (=/= x58 58) (=/= x59 59) (=/= x60 60) (=/= x61 61) (=/= x62 62) (=/= x63 63) (=/= x64 64) (=/= x65 65) (=/= x66 66) (=/= x67 67) (=/= x68 68) (=/= x69 69) (=/= x70 70) (=/= x71 71) (=/= x72 72) (=/= x73 73) (=/= x74 74) (=/= x75 75) (=/= x76 76) (=/= x77 77) (=/= x78 78) (=/= x79 79) (=/= x80 80) (=/= x81 81) (=/= x82 82) (=/= x83 83) (=/= x84 84) (=/= x85 85) (=/= x86 86) (=/= x87 87) (=/= x88 88) (=/= x89 89) (=/= x90 90) (=/= x91 91) (=/= x92 92) (=/= x93 93) (=/= x94 94) (=/= x95 95) (=/= x96 96) (=/= x97 97) (=/= x98 98) (=/= x99 99) (=/= x100 100)))

  (bench "disequality - amortized walk" 1000
         ;; Many copies of constraints on the same variable can amortize variable walking and constraint store modification.
         (run -1 (x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 x51 x52 x53 x54 x55 x56 x57 x58 x59 x60 x61 x62 x63 x64 x65 x66 x67 x68 x69 x70 x71 x72 x73 x74 x75 x76 x77 x78 x79 x80 x81 x82 x83 x84 x85 x86 x87 x88 x89 x90 x91 x92 x93 x94 x95 x96 x97 x98 x99 x100)
           (=/= x1 1) (=/= x2 2) (=/= x3 3) (=/= x4 4) (=/= x5 5) (=/= x6 6) (=/= x7 7) (=/= x8 8) (=/= x9 9) (=/= x10 10) (=/= x11 11) (=/= x12 12) (=/= x13 13) (=/= x14 14) (=/= x15 15) (=/= x16 16) (=/= x17 17) (=/= x18 18) (=/= x19 19) (=/= x20 20) (=/= x21 21) (=/= x22 22) (=/= x23 23) (=/= x24 24) (=/= x25 25) (=/= x26 26) (=/= x27 27) (=/= x28 28) (=/= x29 29) (=/= x30 30) (=/= x31 31) (=/= x32 32) (=/= x33 33) (=/= x34 34) (=/= x35 35) (=/= x36 36) (=/= x37 37) (=/= x38 38) (=/= x39 39) (=/= x40 40) (=/= x41 41) (=/= x42 42) (=/= x43 43) (=/= x44 44) (=/= x45 45) (=/= x46 46) (=/= x47 47) (=/= x48 48) (=/= x49 49) (=/= x50 50) (=/= x51 51) (=/= x52 52) (=/= x53 53) (=/= x54 54) (=/= x55 55) (=/= x56 56) (=/= x57 57) (=/= x58 58) (=/= x59 59) (=/= x60 60) (=/= x61 61) (=/= x62 62) (=/= x63 63) (=/= x64 64) (=/= x65 65) (=/= x66 66) (=/= x67 67) (=/= x68 68) (=/= x69 69) (=/= x70 70) (=/= x71 71) (=/= x72 72) (=/= x73 73) (=/= x74 74) (=/= x75 75) (=/= x76 76) (=/= x77 77) (=/= x78 78) (=/= x79 79) (=/= x80 80) (=/= x81 81) (=/= x82 82) (=/= x83 83) (=/= x84 84) (=/= x85 85) (=/= x86 86) (=/= x87 87) (=/= x88 88) (=/= x89 89) (=/= x90 90) (=/= x91 91) (=/= x92 92) (=/= x93 93) (=/= x94 94) (=/= x95 95) (=/= x96 96) (=/= x97 97) (=/= x98 98) (=/= x99 99) (=/= x100 100)
           (=/= x1 1) (=/= x1 2) (=/= x1 3) (=/= x1 4) (=/= x1 5) (=/= x1 6) (=/= x1 7) (=/= x1 8) (=/= x1 9) (=/= x1 10) (=/= x1 11) (=/= x1 12) (=/= x1 13) (=/= x1 14) (=/= x1 15) (=/= x1 16) (=/= x1 17) (=/= x1 18) (=/= x1 19) (=/= x1 20) (=/= x1 21) (=/= x1 22) (=/= x1 23) (=/= x1 24) (=/= x1 25) (=/= x1 26) (=/= x1 27) (=/= x1 28) (=/= x1 29) (=/= x1 30) (=/= x1 31) (=/= x1 32) (=/= x1 33) (=/= x1 34) (=/= x1 35) (=/= x1 36) (=/= x1 37) (=/= x1 38) (=/= x1 39) (=/= x1 40) (=/= x1 41) (=/= x1 42) (=/= x1 43) (=/= x1 44) (=/= x1 45) (=/= x1 46) (=/= x1 47) (=/= x1 48) (=/= x1 49) (=/= x1 50) (=/= x1 51) (=/= x1 52) (=/= x1 53) (=/= x1 54) (=/= x1 55) (=/= x1 56) (=/= x1 57) (=/= x1 58) (=/= x1 59) (=/= x1 60) (=/= x1 61) (=/= x1 62) (=/= x1 63) (=/= x1 64) (=/= x1 65) (=/= x1 66) (=/= x1 67) (=/= x1 68) (=/= x1 69) (=/= x1 70) (=/= x1 71) (=/= x1 72) (=/= x1 73) (=/= x1 74) (=/= x1 75) (=/= x1 76) (=/= x1 77) (=/= x1 78) (=/= x1 79) (=/= x1 80) (=/= x1 81) (=/= x1 82) (=/= x1 83) (=/= x1 84) (=/= x1 85) (=/= x1 86) (=/= x1 87) (=/= x1 88) (=/= x1 89) (=/= x1 90) (=/= x1 91) (=/= x1 92) (=/= x1 93) (=/= x1 94) (=/= x1 95) (=/= x1 96) (=/= x1 97) (=/= x1 98) (=/= x1 99) (=/= x1 100)))

  (bench "disequality - attribution" 1000
         ;; It is necessary either to store two constraints--one for each attributed variable--or else choose a normalized order so the constraint can always be found when those two variables are unified. This implementation gives each var a unique id, so it can always default to storing constraints on the lower id, preventing it from needing to store the constraint twice.
         (run -1 (x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 x51 x52 x53 x54 x55 x56 x57 x58 x59 x60 x61 x62 x63 x64 x65 x66 x67 x68 x69 x70 x71 x72 x73 x74 x75 x76 x77 x78 x79 x80 x81 x82 x83 x84 x85 x86 x87 x88 x89 x90 x91 x92 x93 x94 x95 x96 x97 x98 x99 x100)
           (=/= x1 x2) (=/= x3 x4) (=/= x5 x6) (=/= x7 x8) (=/= x9 x10) (=/= x11 x12) (=/= x13 x14) (=/= x15 x16) (=/= x17 x18) (=/= x19 x20) (=/= x21 x22) (=/= x23 x24) (=/= x25 x26) (=/= x27 x28) (=/= x29 x30) (=/= x31 x32) (=/= x33 x34) (=/= x35 x36) (=/= x37 x38) (=/= x39 x40) (=/= x41 x42) (=/= x43 x44) (=/= x45 x46) (=/= x47 x48) (=/= x49 x50) (=/= x51 x52) (=/= x53 x54) (=/= x55 x56) (=/= x57 x58) (=/= x59 x60) (=/= x61 x62) (=/= x63 x64) (=/= x65 x66) (=/= x67 x68) (=/= x69 x70) (=/= x71 x72) (=/= x73 x74) (=/= x75 x76) (=/= x77 x78) (=/= x79 x80) (=/= x81 x82) (=/= x83 x84) (=/= x85 x86) (=/= x87 x88) (=/= x89 x90) (=/= x91 x92) (=/= x93 x94) (=/= x95 x96) (=/= x97 x98) (=/= x99 x100)))

  (bench "disequality - laziness" 1000
         ;; Because =/= is a disjunction, we only need to confirm that one pair cannot be decided. We do not need to disunify subsequent pairs.
         (run -1 (x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 x51 x52 x53 x54 x55 x56 x57 x58 x59 x60 x61 x62 x63 x64 x65 x66 x67 x68 x69 x70 x71 x72 x73 x74 x75 x76 x77 x78 x79 x80 x81 x82 x83 x84 x85 x86 x87 x88 x89 x90 x91 x92 x93 x94 x95 x96 x97 x98 x99 x100)
           (=/=
            (list x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 x51 x52 x53 x54 x55 x56 x57 x58 x59 x60 x61 x62 x63 x64 x65 x66 x67 x68 x69 x70 x71 x72 x73 x74 x75 x76 x77 x78 x79 x80 x81 x82 x83 x84 x85 x86 x87 x88 x89 x90 x91 x92 x93 x94 x95 x96 x97 x98 x99 x100)
            (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100))))

    (bench "disequality - early failure" 100
         ;; Instead of waiting until the end of unification to run constraint checks, we can run them as we unify each variable and potentially fail early. This is easier if constraints are already in the substitution and returned by walk, as we can simply deal with them as we unify without calling out to a separate constraint store.
         (run 1 (x)
           (fresh (x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 x51 x52 x53 x54 x55 x56 x57 x58 x59 x60 x61 x62 x63 x64 x65 x66 x67 x68 x69 x70 x71 x72 x73 x74 x75 x76 x77 x78 x79 x80 x81 x82 x83 x84 x85 x86 x87 x88 x89 x90 x91 x92 x93 x94 x95 x96 x97 x98 x99 x100)
             (=/= x1 1)
             (== (list x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 x51 x52 x53 x54 x55 x56 x57 x58 x59 x60 x61 x62 x63 x64 x65 x66 x67 x68 x69 x70 x71 x72 x73 x74 x75 x76 x77 x78 x79 x80 x81 x82 x83 x84 x85 x86 x87 x88 x89 x90 x91 x92 x93 x94 x95 x96 x97 x98 x99 x100)
                 (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100))))))
