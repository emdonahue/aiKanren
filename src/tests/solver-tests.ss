(library (solver-tests) ; Tests the core mechanisms of the constraint solver
  (export run-solver-tests)
  (import (chezscheme) (test-runner) (aikanren) (datatypes) (utils) (state) (solver))
  
  (define (run-solver-tests)
    (define x1 (make-var 1))
    (define x2 (make-var 2))
    (define x3 (make-var 3))
    (define x4 (make-var 4))

    ;; === CON/DISJUNCTION ===
    (tassert "conj fail first" (conj fail succeed) fail)
    (tassert "conj fail rest" (conj succeed fail) fail)
    (tassert "conj compress succeed" (conj succeed succeed) succeed)
    (tassert "conj single goals" (conj* (== 1 1)) (== 1 1))
    (tassert "conj keep normal goals" (conj* (== 1 1) succeed (== 2 2)) (conj* (== 1 1) (== 2 2)))

    (tassert "disj succeed first" (disj succeed fail) succeed)
    (tassert "disj succeed rest" (disj fail succeed) succeed)
    (tassert "disj compress fail" (disj fail fail) fail)
    (tassert "disj single goals" (disj* (== 1 1)) (== 1 1))
    (tassert "disj keep normal goals" (disj* (== 1 1) fail (== 1 1)) (disj (== 1 1) (== 1 1)))

    ;; === SUBSTITUTION ===
    (tassert "substitution constraint-ground fail" (run1 (x1) (=/= x1 1) (== x1 1)) (void))
    (tassert "substitution constraint-ground succeed" (run1 (x1) (=/= x1 1) (== x1 2)) 2)
    (tassert "substitution ground-constraint fail" (run1 (x1) (=/= x1 1) (== 1 x1)) (void))
    (tassert "substitution ground-constraint succeed" (run1 (x1) (=/= x1 1) (== 2 x1)) 2)
    (tassert "substitution constraint-bound fail" (run1 (x1) (== x1 1) (=/= x1 1)) (void))
    (tassert "substitution constraint-bound succeed" (run1 (x1) (== x1 2) (=/= x1 1)) 2)
    (tassert "substitution bound-constraint fail" (run1 (x1) (== 1 x1) (=/= x1 1)) (void))
    (tassert "substitution bound-constraint succeed" (run1 (x1) (== 2 x1) (=/= x1 1)) 2)
    (tassert "substitution constraint-free" (run1 (x1 x2) (=/= x1 1) (== x1 x2)) (list (=/= x2 1) (=/= x2 1)))
    (tassert "substitution constraint-free high var" (run1 (x1 x2) (=/= x2 1) (== x1 x2)) (list (=/= x2 1) (=/= x2 1)))
    (tassert "substitution free-constraint" (run1 (x1 x2) (=/= x1 1) (== x2 x1)) (list (=/= x2 1) (=/= x2 1)))
    (tassert "substitution free-constraint high var" (run1 (x1 x2) (=/= x2 1) (== x2 x1)) (list (=/= x2 1) (=/= x2 1)))
    
    (tassert "substitution constraint-constraint" (run1 (x1) (=/= x1 1) (=/= x1 2)) (conj (=/= x1 2) (=/= x1 1)))
    (tassert "substitution constraint-constraint-free" (run1 (x1 x2) (=/= x1 1) (=/= x2 2) (== x1 x2)) (list (conj (=/= x2 2) (=/= x2 1)) (conj (=/= x2 2) (=/= x2 1))))
    (tassert "substitution constraint-constraint-free2" (run1 (x1 x2) (=/= x1 1) (=/= x2 2) (== x2 x1)) (list (conj (=/= x2 2) (=/= x2 1)) (conj (=/= x2 2) (=/= x2 1))))
    (tassert "substitution constraint disunify free" (run1 (x1 x2) (=/= x1 1) (=/= x1 x2)) (list (conj (=/= x1 x2) (=/= x1 1)) x2))
    (tassert "substitution constraint disunify free2" (run1 (x1 x2) (=/= x2 1) (=/= x1 x2)) (list (=/= x1 x2) (=/= x2 1)))
    ;;TODO implement disunification solver
					;(org-trace    (tassert "substitution constraint disunify bound" (run1 (x1) (=/= x1 1) (=/= 1 x1)) (=/= x1 1)))

    (tassert "substitution pconstraint-ground fail" (run1 (x1) (symbolo x1) (== x1 1)) (void))
    (tassert "substitution ground-pconstraint fail" (run1 (x1) (== x1 1) (symbolo x1)) (void))
    (tassert "substitution pconstraint-ground succeed" (run1 (x1) (symbolo x1) (== x1 'symbol)) 'symbol)
    (tassert "substitution ground-pconstraint succeed" (run1 (x1) (== x1 'symbol) (symbolo x1)) 'symbol)
    (tassert "substitution pconstraint-constraint" (run1 (x1) (symbolo x1) (=/= x1 1)) (symbolo x1))
    (tassert "substitution pconstraint-constraint" (run1 (x1) (=/= x1 1) (symbolo x1)) (lambda (c) (and (conj? c) (equal? (conj-lhs c) (=/= x1 1)) (and (pconstraint? (conj-rhs c)) (equal? (pconstraint-vars (conj-rhs c)) (list x1))))))

    (tassert "eq? variables must not unify when constrained" (run1 (x1) (=/= x1 1) (== x1 x1)) (=/= x1 1))
    (tassert "eq? variables must not disunify when constrained" (run1 (x1) (=/= x1 1) (=/= x1 x1)) (void))

    ;; === ATTRIBUTED VARIABLES ===

    (tassert "disequalities attribute only to first var" (run1 (x1 x2) (=/= (cons x1 x2) '(1 . 2))) (list (disj (=/= x1 1) (=/= x2 2)) x2))
    (tassert "disj of disequalities attribute only to first var" (run1 (x1 x2) (disj (=/= x1 1) (=/= x2 2))) `(,(disj (=/= x1 1) (=/= x2 2)) ,x2))


    ;; Single variable
    (tassert "attribute x1=1=>x1=/=x1=>fail" (run1 (x1) (disj (=/= x1 1) (== x1 2))) (disj (=/= x1 1) (== x1 2))) ; TODO can we simplify disjunctions of == and =/= of the same var? technically should be simplified to x1 =/= 1
    (tassert "attribute to negation if second and promote" (run1 (x1) (disj (== x1 1) (=/= x1 1))) (disj (=/= x1 1) (== x1 1)))
    (tassert "attribute ~1=>2,~2=>1" (run1 (x1) (disj (== x1 1) (== x1 2))) (disj (== x1 1) (== x1 2)))

    ;; Multi variable
    (tassert "attribute ~x1=>x2, ~x2=>x1" (run1 (x1 x2) (disj (== x1 1) (== x2 2)))
	     (list (disj (== x1 1) (== x2 2)) (disj (== x1 1) (== x2 2)))) 
    (tassert "attribute x1=>x2, ~x2=>x1" (run1 (x1 x2) (disj (== x1 1) (conj (== x1 1) (== x2 2)))) (list 1 x2))
    (tassert "attribute x1=>x2, x2=>x1" (run1 (x1 x2 x3) (disj (conj (== x1 1) (== x2 2)) (== x3 3)))
	     (list (disj (conj (== x1 1) (== x2 2)) (== x3 3))
		   (disj (conj (== x1 1) (== x2 2)) (== x3 3))
		   (disj (conj (== x1 1) (== x2 2)) (== x3 3))))
    (tassert "attribute == =/=" (run1 (x1 x2) (disj (== x1 1) (=/= x2 2)))
	     (list x1 (disj (=/= x2 2) (== x1 1))))
    (tassert "attribute =/= ==" (run1 (x1 x2) (disj (=/= x2 2) (== x1 1)))
	     (list x1 (disj (=/= x2 2) (== x1 1))))
    

    ;; Multi variable with negation
    (tassert "attribute x1:x1=1=>x2=2" (run1 (x1 x2) (disj (=/= x1 1) (== x2 2)))
	     (list (disj (=/= x1 1) (== x2 2)) x2))
    
    (tassert "attribute x1:x1=1=>x2=2, x3:x3~3=>x2=2, x2:x2~2=>x3=3" (run1 (x1 x2 x3) (disj (conj (=/= x1 1) (== x3 3)) (== x2 2)))
	     (list (disj (conj (=/= x1 1) (== x3 3)) (== x2 2))
		   (disj (conj (=/= x1 1) (== x3 3)) (== x2 2))
		   (disj (conj (=/= x1 1) (== x3 3)) (== x2 2))))

    ;; Multi variable with fresh
    (tassert "attribute x1:~x1=>x2=2" (run1 (x1 x2) (disj (matcho [(x1 (a . d))]) (== x2 2)))
	     (lambda (a) (and (disj? (car a)) (matcho? (disj-lhs (car a))) (equal? (disj-rhs (car a)) (== x2 2)) (equal? x2 (cadr a)))))
    
    ;; === SOLVER ===
    (tassert "constraint ==" (run1 (x1) (constrain (== x1 1))) 1)
    (tassert "constraint =/=" (run1 (x1) (constrain (=/= x1 1))) (=/= x1 1))
    (tassert "constraint fail|succeed" (run1 (x1) (constrain (conde [(== x1 1) (== x1 2)] [(== 3 3)]))) x1)
    (tassert "constraint fail|==" (run1 (x1) (constrain (conde [(== x1 1) (== x1 2)] [(== x1 3)]))) 3)
    (tassert "constraint ==|== ==" (run1 (x1) (constrain (conde [(== x1 1)] [(== x1 2)])) (constrain (== x1 1))) 1)
    (tassert "constraint =/= ==|==" (run1 (x1) (constrain (=/= x1 1)) (constrain (conde [(== x1 1)] [(== x1 2)]))) 2)
    (tassert "constraint ==|== =/=" (run1 (x1) (constrain (conde [(== x1 1)] [(== x1 2)])) (constrain (=/= x1 1))) 2)
    (tassert "constraint &" (run1 (x1 x2) (== x1 1) (=/= x2 2)) (list 1 (=/= x2 2)))
    (tassert "constraint |" (run1 (x1) (constrain (conde ((== x1 1)) ((== x1 2))))) (disj* (== x1 1) (== x1 2)))
    (tassert "constraint == fail|==" (run1 (x1 x2) (constrain (== x1 1)) (constrain (conde ((== x1 2)) ((== x2 2))))) '(1 2))
    (tassert "constraint == succeed|==" (run1 (x1 x2) (constrain (== x1 1)) (constrain (conde ((== x1 1)) ((== x2 2))))) (list 1 x2))
    (tassert "constraint == ==|fail" (run1 (x1 x2) (constrain (== x1 1)) (constrain (conde ((== x2 2)) ((== x1 2))))) '(1 2))
    (tassert "constraint == ==|succeed" (run1 (x1 x2) (constrain (== x1 1)) (constrain (conde ((== x2 2)) ((== x1 1))))) (list 1 x2))
    (tassert "constraint == ==|succeed(out)" (run1 (x1 x2 x3) (constrain (== x1 1)) (constrain (== x3 3) (conde ((== x2 2)) ((== x1 1))))) (list 1 x2 3))
    (tassert "constraint == ==|==|=="
	     (run1 (x1 x2 x3) (constrain (== x3 1))
		   (constrain (conde ((== x1 x3)) ((== x2 x3)) ((== x1 x3)))))
	     (list (disj (disj (== x1 1) (== x2 1)) (== x1 x3))
		   (disj (disj (== x1 1) (== x2 1)) (== x1 x3)) 1))
    (tassert "constraint ==|== ==" (run1 (x1) (constrain (conde ((== x1 1)) ((== x1 2)))) (constrain (== x1 1))) 1)
    (tassert "constraint =/=|=/= ==" (run1 (x1) (constrain (disj* (=/= x1 1) (=/= x1 2))) (constrain (== x1 1))) 1)
    (tassert "constraint =/=|=/= ==2" (run1 (x1 x2) ; =/= dont need to simplify, so just apply the == and move on
					    (constrain (disj* (=/= x1 1) (=/= x2 1)))
					    (constrain (== x2 1)))
	     (list (disj* (=/= x1 1) (=/= x2 1)) 1)) 
    (tassert "constraint simplification lvl 2" (run1 (x1 x2 x3 x4) (constrain (== x4 1)) (constrain (conde ((== x1 x4)) ((== x2 x4)) ((== x3 x4)))))
	     (list (disj (disj (== x1 1) (== x2 1)) (== x3 x4)) (disj (disj (== x1 1) (== x2 1)) (== x3 x4)) x3 1))
    (tassert "constraint =/=* fails &== failing all =/=" (run1 (x1 x2) (== x1 1) (== x2 2) (constrain (=/= (cons x1 x2) '(1 . 2)))) (void))
    (tassert "disj head disj preserves ctn" (run1 (x1 x2) (constrain (disj* (constraint (disj* (=/= x1 1) (=/= x1 1))) (== x1 1)) (== x2 2)) (== x1 1)) '(1 2))
    (tassert "disj preserves ctn" (run1 (x1 x2) (constrain (disj* (=/= x1 1) (=/= x1 1) (== x1 1)) (== x2 2)) (== x1 1)) '(1 2))
    (tassert "disj only walks 1st disjunct if no ==" (run1 (x1 x2) (== x2 2) (constrain (conde [(=/= x1 1)] [(=/= x2 2)]))) (list (disj (=/= x1 1) (=/= x2 2)) 2))
    
    ;; === DISEQUALITY ===

    (tassert "disunify ground-self" (run* (q) (=/= 2 2)) '())
    (tassert "disunify ground-different" (run* () (=/= 1 2)) '(()))
    (tassert "disunify free-self" (run* (x1) (=/= x1 x1)) '())
    (tassert "disunify free-ground" (run1 (x1) (=/= x1 1)) (=/= x1 1))
    (tassert "disunify ground-free" (run1 (x1) (=/= 1 x1)) (=/= x1 1))
    (tassert "disunify free-free" (run1 (x1 x2) (=/= x1 x2)) (list (=/= x1 x2) x2))
    (tassert "disunify bound" (run* (x1) (== x1 1) (=/= x1 1)) '())
    (tassert "disunify check" (run* (x1) (=/= x1 1) (== x1 1)) '())
    (tassert "disunify free-ground x2" (run1 (x1) (=/= x1 2) (=/= x1 1)) (conj* (=/= x1 1) (=/= x1 2)))
    (tassert "disunify transfer to free then check" (run* (x1 x2) (=/= x1 2) (== x1 x2) (== x2 2)) '())
    (tassert "disunify lists" (car (run1 (x1 x2) (=/= (cons x1 x2) (cons 1 2)))) (disj* (=/= x1 1) (=/= x2 2)))
    (tassert "disunify fire lists" (run1 (x1 x2) (=/= (cons x1 x2) (cons 1 2)) (== x1 1)) (list 1 (=/= x2 2)))
    (tassert "disunify fire lists and fail" (run* (x1 x2) (=/= (cons x1 x2) (cons 1 2)) (== x1 1) (== x2 2)) '())
    (tassert "disunify simultaneous list diseq" (run* (x1 x2) (=/= (cons x1 x2) (cons 1 2)) (== (cons x1 x2) (cons 1 2))) '())
    (tassert "disunify simultaneous list diseq, fail on first" (run* (x1 x2) (=/= x1 1) (== (cons x1 x2) (cons 1 2))) '())
    (tassert "disunify simultaneous list diseq, fail on second" (run* (x1 x2) (=/= x2 2) (== (cons x1 x2) (cons 1 2))) '())
    (tassert "disunify transfer on free-free up varid" (run1 (x1 x2) (=/= x1 1) (== x1 x2)) (list (=/= x2 1) (=/= x2 1)))
    (tassert "disunify transfer on free-free down varid" (run1 (x1 x2) (=/= x2 1) (== x2 x1)) (list (=/= x2 1) (=/= x2 1)))
    (tassert "disunify fire low varid" (run1 (x1 x2) (=/= x1 x2) (== x2 x1)) (void))
    (tassert "disunify conj" (run1 (x1 x2) (=/= x1 1) (=/= x2 2) (== x1 x2))
	     (list (conj (=/= x2 2) (=/= x2 1)) (conj (=/= x2 2) (=/= x2 1))))
    (tassert "disunify fire low varid" (run1 (x1 x2) (== x2 1) (=/= x1 1) (== x1 x2)) (void))
    (tassert "disunify fire high varid" (run1 (x1 x2) (== x1 1) (=/= x2 1) (== x1 x2)) (void))
    (tassert "disunify fired constraints restored on failure" (run1 (x1) (disj (== x1 1) (== x1 1)) (=/= (list x1 x1) '(1 1))) (void))
    (tassert "disunify disjunction builds continuation" (run1 (x1) (disj (== x1 1) (== x1 2)) (=/= (list x1 x1) '(3 3)))
	     (disj (== x1 1) (== x1 2)))
    (tassert "disunify disjunction runs ctn" (run1 (x1) (constrain (=/= (list x1 x1) '(1 1)) (== x1 1))) (void))
    (tassert "disunify disjunction runs ctn" (run1 (x1) (constrain (=/= (list x1 x1) '(1 1)) (== x1 1))) (void))

    (tassert "disunify simplify simple abort" (run1 (x1) (=/= x1 1) (=/= x1 1)) (=/= x1 1))
    (tassert "disunify simplify ignores conj" (run1 (x1) (=/= x1 1) (=/= x1 2) (=/= x1 3)) (conj (=/= x1 3) (conj (=/= x1 2) (=/= x1 1))))
    (tassert "disunify simplify conj early succeed" (run1 (x1) (conj (=/= x1 1) (=/= x1 2)) (=/= x1 1)) (conj (=/= x1 2) (=/= x1 1)))
    (tassert "disunify simplify abort pconstraint" (run1 (x1) (symbolo x1) (=/= x1 1)) (symbolo x1))    
    (tassert "disunify simplify ignore pconstraint" (run1 (x1) (numbero x1) (=/= x1 1)) (conj (=/= x1 1) (numbero x1)))
    (tassert "disunify simplify abort negative pconstraint" (run1 (x1) (noto (numbero x1)) (=/= x1 1)) (noto (numbero x1)))
    (tassert "disunify simplify matcho succeed" (run1 (x1) (constrain (matcho ([x1 (a . d)]))) (=/= x1 1)) (lambda (c) (matcho? c)))
    (tassert "disunify simplify matcho" (run1 (x1) (constrain (matcho ([x1 (a . d)]))) (=/= x1 '(1 . 2))) (lambda (c) (and (conj? c) (equal? (conj-lhs c) (=/= x1 '(1 . 2))) (matcho? (conj-rhs c)))))
    (tassert "disunify simplify negative matcho" (run1 (x1) (constrain (noto (matcho ([x1 (a . d)])))) (=/= x1 1)) (lambda (c) (and (conj? c) (matcho? (noto-goal (conj-rhs c))) (equal? (conj-lhs c) (=/= x1 1)))))
    (tassert "disunify simplify disjunction fails first" (run1 (x1 x2) (disj (== x2 2) (== x1 1)) (=/= x1 1)) (list (=/= x1 1) 2))
    (tassert "disunify simplifies secondary constraint if primary is val" (run1 (x1 x2) (== x1 1) (disj (== x2 1) (== x2 2)) (=/= x1 x2)) '(1 2))
    (tassert "disunify suspends and preserves whole ctn" (run1 (x1 x2 x3) (constrain (=/= (cons x1 x2) '(())) (== x3 1))) (list (disj (=/= x1 '()) (=/= x2 '())) x2 1))
    (tassert "disunify preserves pending goals in ctn" (run1 (x1 x2) (constrain (=/= x1 1) (disj (=/= x2 1) (=/= x2 2)))) (list (=/= x1 1) (disj (=/= x2 1) (=/= x2 2))))
    (tassert "disunify simplify drops when =/= in a conj" (run1 (x1) (disj (conj (=/= x1 1) (conj (numbero x1) (=/= x1 1))) (=/= x1 2))) (disj (conj (=/= x1 1) (numbero x1)) (=/= x1 2)))

    ;; === EQUALITY ===
    
    (tassert "==-c ground-self" (run1 (x1) (constrain (== 1 1))) x1)
    (tassert "==-c ground-different" (run1 (x1) (constrain (== 1 2))) (void))
    (tassert "==-c free-ground" (run1 (x1) (constrain (== x1 1))) 1)
    (tassert "==-c bound-ground-same" (run1 (x1) (== x1 1) (constrain (== x1 1))) 1)
    (tassert "==-c bound-ground-different" (run1 (x1) (== x1 2) (constrain (== x1 1))) (void))
    (tassert "==-c ground-bound-same" (run1 (x1) (constrain (== x1 1)) (== x1 1)) 1)
    (tassert "==-c ground-bound-different" (run1 (x1) (constrain (== x1 1)) (== x1 2)) (void))
    (tassert "==-c x ==-c conflict" (run1 (x1) (constrain (== x1 1)) (constrain (== x1 2))) (void))
    (tassert "==-c x ==-c no conflict" (run1 (x1) (constrain (== x1 1)) (constrain (== x1 1))) 1)
    (tassert "==-c & ==-c conflict" (run1 (x1) (constrain (conj* (== x1 2) (== x1 1)))) (void))
    (tassert "==-c & ==-c no conflict" (run1 (x1) (constrain (conj* (== x1 1) (== x1 1)))) 1)
    (tassert "==-c x =/=-c conflict" (run1 (x1) (=/= x1 1) (constrain (== x1 1))) (void))
    (tassert "==-c x =/=-c no conflict" (run1 (x1) (=/= x1 2) (constrain (== x1 1))) 1)
    (tassert "==-c | ==-c" (run1 (x1) (constrain (disj* (== x1 1) (== x1 2)))) (disj (== x1 1) (== x1 2)))
    (tassert "==-c | ==-c attributes" (run1 (x1 x2) (constrain (disj* (== x1 1) (== x2 2)))) (list (disj (== x1 1) (== x2 2)) (disj (== x1 1) (== x2 2))))
    (tassert "==-c | ==-c simplifies bound"
	     (run1 (x1 x2) (== x1 1) (constrain (disj* (== x1 1) (== x2 2)))) (list 1 x2))
    (tassert "==-c | ==-c transfers bound"
	     (run1 (x1 x2) (== x1 3) (constrain (disj* (== x1 1) (== x2 2)))) (list 3 2))
    (let ([s (list (cons x1 1))]
	  [s-free (list (cons x1 x2))]
	  [s-pair (list (cons x1 (cons x2 x3)))])
      (tassert "simplify == & ==" (simplify-unification (== x1 1) s) (list succeed succeed))
      (tassert "simplify == & ==!" (simplify-unification (== x1 2) s) (list fail fail))
      (tassert "simplify == & ==^" (simplify-unification (== x1 x2) s) (list (== x2 1) succeed))
      (tassert "simplify == & ==?" (simplify-unification (== x2 2) s) (list (== x2 2) succeed))
      (tassert "simplify == & ==*" (simplify-unification (== x1 '(2 . 3)) s-pair) (list (conj (== x3 3) (== x2 2)) succeed))
      (tassert "simplify == & ==!&==" (simplify-unification (conj (== x1 2) (== x1 1)) s) (list fail fail))
      (tassert "simplify == & ==&==!" (simplify-unification (conj (== x1 1) (== x1 2)) s) (list fail fail))

      (tassert "simplify == & =/=" (simplify-unification (=/= x1 1) s) (list fail succeed))
      (tassert "simplify == & =/=!" (simplify-unification (=/= x1 2) s) (list succeed succeed))
      (tassert "simplify == & =/=?" (simplify-unification (=/= x1 1) s-free) (list (=/= x2 1) succeed))

      (tassert "simplify == & satisfied" (simplify-unification (numbero x1) s) (list succeed succeed))
      (tassert "simplify == & not satisfied" (simplify-unification (noto (numbero x1)) s) (list fail succeed))
      (tassert "simplify == & unsatisfiable" (simplify-unification (symbolo x1) s) (list fail fail))
      (tassert "simplify == & not unsatisfiable" (simplify-unification (noto (symbolo x1)) s) (list succeed succeed))
      (tassert "simplify == & undecidable" (simplify-unification (symbolo x2) s) (list (symbolo x2) succeed))
      (tassert "simplify == & not undecidable" (simplify-unification (noto (symbolo x2)) s) (list (noto (symbolo x2)) succeed))
      (tassert "simplify ==f & undecidable" (simplify-unification (symbolo x1) s-free) (list (symbolo x2) succeed))
      (tassert "simplify ==f & not undecidable" (simplify-unification (noto (symbolo x1)) s-free) (list (noto (symbolo x2)) succeed))

      (tassert "simplify == & matcho fail" (simplify-unification (matcho ([x1 (a . d)])) s) (list fail fail))
      (tassert "simplify == & matcho simplified" (simplify-unification (matcho ([x1 (a . d)])) s-free) (lambda (g) (and (succeed? (cadr g)) (matcho? (car g)) (eq? x2 (car (matcho-out-vars (car g)))))))
      (tassert "simplify == & matcho recheck" (simplify-unification (matcho ([x1 (a . d)] [x2 (b . c)])) `((,x1 . (1 . 2)) (,x2 . (3 . 4)))) (lambda (g) (and (succeed? (car g)) (matcho? (cadr g)) (null? (matcho-out-vars (cadr g))) (equal? '((3 . 4) (1 . 2)) (matcho-in-vars (cadr g))))))
      (tassert "simplify == & not matcho succeed" (simplify-unification (noto (matcho ([x1 (a . d)]))) s) (list succeed succeed))
      
      
      )

    ;; === DISJUNCTION ===

    (tassert "== factored out of disj" (run1 (x1) (disj (== x1 1) (== x1 1))) 1)
    (tassert "== factored out of nested disj" (run1 (x1 x2) (== x2 2) (disj (conj (== x2 2) (disj (== x1 1) (== x1 1))) (== x2 3))) '(1 2))
    (tassert "== factored out of nested disj tail" (run1 (x1 x2) (== x2 2) (disj (== x1 1) (conj (== x2 2) (disj (== x1 1) (== x1 1))))) '(1 2))
    (tassert "nested disj terminates disj solving" (run1 (x1 x2) (== x2 2) (disj (== x1 1) (conj (== x2 2) (disj (== x1 2) (== x1 1))))) (list (disj (disj (== x1 2) (== x1 1)) (== x1 1)) 2))
    (tassert "=/= & (=/=|succeed)" (run1 (x1) (disj (numbero x1) (symbolo x1)) (=/= x1 1)) (disj (conj (=/= x1 1) (numbero x1)) (symbolo x1)))
    (tassert "== succeed" (simplify-=/= (== x1 1) x1 1 (=/= x1 1)) (list succeed fail succeed (=/= x1 1)))
    (tassert "== undecidable" (simplify-=/= (== x1 (cons x2 x3)) x1 (cons x3 x2) (=/= x1 1)) (list (== x1 (cons x2 x3)) (== x1 (cons x2 x3)) succeed (=/= x1 1)))
    (tassert "=/= undecidable" (simplify-=/= (=/= x1 (cons x2 x3)) x1 (cons x3 x2) (=/= x1 1)) (list (=/= x1 (cons x2 x3)) (=/= x1 (cons x2 x3)) succeed (=/= x1 1)))
    (tassert "symbolo fail" (simplify-=/= (symbolo x1) x1 1 (=/= x1 1)) (list fail (symbolo x1) succeed (=/= x1 1)))
    (tassert "symbolo2 undecidable" (simplify-=/= (symbolo x1) x2 1 (=/= x1 1)) (list (symbolo x1) (symbolo x1) succeed (=/= x1 1)))
    (tassert "not numbero fail" (simplify-=/= (noto (numbero x1)) x1 1 (=/= x1 1)) (list fail (noto (numbero x1)) succeed (=/= x1 1)))
    (tassert "=/= fail" (simplify-=/= (=/= x1 1) x1 1 (=/= x1 1)) (list fail succeed succeed (=/= x1 1)))
    (tassert "=/= succeed" (simplify-=/= (=/= x1 2) x1 1 (=/= x1 1)) (list succeed (=/= x1 2) succeed (=/= x1 1)))
    (tassert "conj fail" (simplify-=/= (conj (== x1 1) (=/= x1 1)) x1 1 (=/= x1 1)) (list fail fail succeed (=/= x1 1)))
    (tassert "matcho fail" (simplify-=/= (matcho ([x1 (a . d)])) x1 1 (=/= x1 1)) (lambda (a) (and (fail? (list-ref a 0)) (matcho? (list-ref a 1)) (equal? (cddr a) (list succeed (=/= x1 1))))))
    (tassert "matcho2 undecidable" (simplify-=/= (matcho ([x1 (a . d)])) x2 1 (=/= x1 1)) (lambda (a) (and (matcho? (car a)) (matcho? (cadr a)) (succeed? (caddr a))) (=/= x1 1)))
    (tassert "not matcho succeed" (simplify-=/= (noto (matcho ([x1 (a . d)]))) x1 1 (=/= x1 1)) (lambda (a) (and (succeed? (car a)) (noto? (cadr a)) (succeed? (caddr a)) (equal? (cadddr a) (=/= x1 1)))))
    (tassert "matcho undecidable" (simplify-=/= (matcho ([x1 (a . d)])) x1 '(1 . 2) (=/= x1 1)) (lambda (a) (and (matcho? (car a)) (matcho? (cadr a)) (succeed? (caddr a))) (=/= x1 1)))
    (tassert "not matcho undecidable" (simplify-=/= (noto (matcho ([x1 (a . d)]))) x1 '(1 . 2) (=/= x1 '(1 . 2))) (lambda (a) (and (noto? (car a)) (noto? (cadr a)) (succeed? (caddr a))) (=/= x1 '(1 . 2))))
    (tassert "=/= satisfied|satisfies" (simplify-=/= (disj (=/= x1 1) (symbolo x1)) x1 1 (=/= x1 1)) (list fail succeed succeed (=/= x1 1)))
    (tassert "=/= satisfies|satisfies" (simplify-=/= (disj (symbolo x1) (symbolo x1)) x1 1 (=/= x1 1)) (list fail (symbolo x1) succeed succeed))
    (tassert "=/= satisfies|satisfied|unnormalized" (simplify-=/= (disj (=/= x1 1) (disj (symbolo x1) (=/= x2 2))) x1 1 (=/= x1 1)) (list fail succeed succeed (=/= x1 1)))
    (tassert "=/= satisfied|satisfied|unnormalized" (simplify-=/= (disj (symbolo x1) (disj (symbolo x1) (=/= x2 2))) x1 1 (=/= x1 1)) (list (=/= x2 2) (disj (symbolo x1) (disj (symbolo x1) (conj (=/= x1 1) (=/= x2 2)))) succeed succeed))
    (tassert "=/= unsatisfiable|satisfied" (simplify-=/= (disj (== x1 1) (symbolo x1)) x1 1 (=/= x1 1)) (list succeed succeed (symbolo x1) succeed))
    (tassert "=/= satisfied|unsatisfiable" (simplify-=/= (disj (symbolo x1) (== x1 1)) x1 1 (=/= x1 1)) (list succeed (symbolo x1)  succeed succeed))
    (tassert "=/= satisfied|unsatisfiable|undecidable" (simplify-=/= (disj (symbolo x1) (disj (== x1 1) (=/= x1 2))) x1 1 (=/= x1 1)) (list succeed succeed (disj (symbolo x1) (conj (=/= x1 1) (=/= x1 2))) succeed))
    (tassert "=/= satisfied|undecidable" (simplify-=/= (disj (symbolo x1) (=/= x1 2)) x1 1 (=/= x1 1)) (list succeed (disj (symbolo x1) (conj (=/= x1 1) (=/= x1 2))) succeed succeed))
    (tassert "=/= unsatisfiable|undecidable" (simplify-=/= (disj (== x1 1) (=/= x1 2)) x1 1 (=/= x1 1)) (list succeed succeed (conj (=/= x1 1) (=/= x1 2)) succeed))
    (tassert "=/= undecidable|unsatisfiable" (simplify-=/= (disj (=/= x1 2) (== x1 1)) x1 1 (=/= x1 1)) (list succeed (conj (=/= x1 1) (=/= x1 2)) succeed succeed))
    (tassert "=/= undecidable|undecidable" (simplify-=/= (disj (=/= x1 2) (=/= x1 3)) x1 1 (=/= x1 1)) (list succeed (conj (=/= x1 1) (disj (=/= x1 2) (=/= x1 3))) succeed succeed))
    (tassert "=/= recheck|undecidable" (simplify-=/= (disj (conj (=/= x2 2) (disj (== x1 1) (=/= x2 3))) (=/= x1 3)) x1 1 (=/= x1 1)) (list succeed succeed (disj (conj (=/= x2 2) (conj (=/= x1 1) (=/= x2 3))) (=/= x1 3)) succeed))
    (tassert "=/= satisfied|recheck" (simplify-=/= (disj (symbolo x1) (conj (=/= x2 2) (disj (== x1 1) (=/= x2 3)))) x1 1 (=/= x1 1)) (list succeed succeed (disj (symbolo x1) (conj (=/= x2 2) (conj (=/= x1 1) (=/= x2 3)))) succeed))
    (tassert "=/= satisfies|undecidable" (simplify-=/= (disj (=/= x1 1) (=/= x1 2)) x1 1 (=/= x1 1)) (list fail succeed succeed (=/= x1 1)))
    (tassert "=/= undecidable|satisfies" (simplify-=/= (disj (=/= x1 2) (=/= x1 1)) x1 1 (=/= x1 1)) (list fail succeed succeed (=/= x1 1)))
    (tassert "=/= =/=^|=/=^|=/=" (simplify-=/= (disj (=/= x1 2) (disj (=/= x1 3) (=/= x1 1))) x1 1 (=/= x1 1)) (list fail succeed succeed (=/= x1 1)))
    (tassert "=/= ==^|==^|==" (simplify-=/= (disj (disj (== x1 2) (== x1 3)) (== x1 1)) x1 1 (=/= x1 1)) (list succeed (disj (== x1 2) (== x1 3)) succeed succeed))
    (tassert "=/= ==^|==^|==|==^" (simplify-=/= (disj (disj (disj (== x1 2) (== x1 3)) (== x1 1)) (== x1 4)) x1 1 (=/= x1 1)) (list succeed (disj (disj (== x1 2) (== x1 3)) (== x1 4)) succeed succeed))
    (tassert "=/= (recheck&recheck)|undecidable" (simplify-=/= (disj (conj (disj (== x1 1) (=/= x2 3)) (disj (== x1 1) (=/= x2 3))) (=/= x1 3)) x1 1 (=/= x1 1)) (list succeed succeed (disj (conj (conj (=/= x1 1) (=/= x2 3)) (=/= x2 3)) (=/= x1 3)) succeed))
    (tassert "=/= (satisfies|undecidable)|(satisfied|undecidable)" (simplify-=/= (disj (conj (=/= x1 2) (disj (=/= x1 1) (=/= x1 3))) (conj (=/= x1 4) (disj (symbolo x1) (=/= x1 5)))) x1 1 (=/= x1 1)) (list succeed (disj (=/= x1 2) (conj (=/= x1 4) (disj (symbolo x1) (conj (=/= x1 1) (=/= x1 5))))) succeed succeed))
    (tassert "disj common non == are extracted" (run1 (x1) (disj (=/= x1 1) (=/= x1 1))) (=/= x1 1))

    ;; === MATCHO ===
;;(org-trace    (tassert "matcho doesnt blend" (caddr (run1 (x1 x2 x3) (== x1 (cons x2 x3)) (absento 'closure x1))) 1))
    (tassert "matcho doesn't overwrite =/=" (run1 (x1) (=/= x1 '(())) (matcho ([x1 (a . d)]) (== a 1) (== d 2))) '(1 . 2))
;;    (tassert "matcho doesnt double count itself in disj simplification" (run1 (x1 x2 x3) (== x1 (cons x2 x3)) (disj (matcho ([x1 (a . d)]) (=/= a d)) (=/= x1 1))) 1)
  
    ))
