(library (state-tests)
  (export run-state-tests)
  (import (chezscheme) (test-runner) (state) (datatypes) (utils) (aikanren))
  
  (define (run-state-tests)
    (define x1 (make-var 1))
    (define x2 (make-var 2))
    (tassert "state walk ground" (walk empty-state 2) 2)
    (tassert "state walk free" (walk empty-state x1) x1)
    (tassert "state reify ground" (reify empty-state 2) 2)
    (tassert "state reify free" (reify empty-state x1) x1)
    (tassert "state reify bound" (reify (values-ref (unify empty-state x1 1) 2) x1) 1)
    (tassert "state reify pair" (reify (values-ref (unify empty-state x1 1) 2) (cons 2 (cons x1 x2))) (cons 2 (cons 1 x2)))
    (tassert "state unify ground-ground" (values-ref (unify empty-state 2 2) 2) empty-state)
    (tassert "state unify free-ground" (walk (values-ref (unify empty-state x1 2) 2) x1) 2)
    (tassert "state unify free-ground" (walk (values-ref (unify empty-state 2 x1) 2) x1) 2)
    (tassert "state unify variable to itself" (values-ref (unify empty-state x1 x1) 2) empty-state)
    (tassert "state unify free-free" (walk (values-ref (unify empty-state x1 x2) 2) x1) x2)
    (tassert "state unify free-free inverse priority" (walk (values-ref (unify empty-state x2 x1) 2) x1) x2)
    (tassert "state unify cars" (walk (values-ref (unify empty-state (cons x1 1) (cons 2 1)) 2) x1) 2)
    (tassert "state unify cars fail" (values-ref (unify empty-state (cons 1 x1) (cons 2 1)) 2) failure)
    (tassert "state unify cdrs" (walk (values-ref (unify empty-state (cons 1 x1) (cons 1 2)) 2) x1) 2)
    (tassert "state unify cdrs fail" (values-ref (unify empty-state (cons x1 2) (cons 2 1)) 2) failure)

    (tassert "state reify cyclic" (run1 (x1) (== x1 (cons x1 x1))) (cons x1 x1))
    ))
